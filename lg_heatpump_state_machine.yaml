lambda: !lambda |-
    
    //State machine, main algoritm that runs every 'clock' cycle
    //INIT: Initial startup (very early after boot)
    //IDLE: No heat request, wait for thermostat on
    //START: Set values and start HP
    //STARTING: Early start, temporary state (waiting for compressor start)
    //STABILIZE: Early in the run < 20 minutes of compressor time or not stable yet
    //RUN: HP operating with target = stooklijn_target (+/- 1 ) and no intervention. Decides on intevention (STALL, OVERSHOOT)
    //OVERSHOOT: Raising target above stooklijn_target to prevent compressor stop, should return to RUN when done
    //STALL: Temperature below target, returns to RUN when within limits
    //WAIT: Compressor has stopped during run with still heating request (so algoritm failed)
    //SWW: HP operating to create hot water
    //DEFROST: HP operating defrost cycle
    //AFTERRUN: Run done (no more heating request) external pump runs
    
    //main state machine object
    static state_machine_class fsm; //state machine main object
    static uint_fast32_t dt = round(id(state_machine).get_update_interval()/1000); //update interval in seconds
    fsm.increment_run_time(dt); //increment fsm run_time
    
    //do not run this until INIT is finished
    if(fsm.state() != INIT){
      //Receive inputs
      fsm.receive_inputs();
      //Translate Events
      //Transition state
      //Check fail safes
      
    }

    //process state
    //***************************************************************
    //*******************State Machine States************************
    //***************************************************************
    switch (fsm.state()) {
      case INIT: {
        //DESCRIPTION: Early start. Wait for 1 minute to allow all sensor values to populate. Has 'instant on' mode to bypass some checks
        //INTERPRETS INPUTS: THERMOSTAT_SENSOR (for instant on)
        //RECEIVES EVENTS: none
        //STATE TRANSITIONS: START; IDLE
        //SPECIAL: reads raw values to determine if setup is complete
        //wait for timeout
        if(fsm.get_run_time() < 60 || isnan(id(buiten_temp).state) || isnan(id(water_temp_aanvoer).state) || isnan(id(water_temp_retour).state)) break;
        //after timeout
        id(derivative_value).publish_state(0);
        id(average_cop_sensor).publish_state(0);
        id(update_stooklijn) = true; //force update
        fsm.receive_inputs();
        //check for fast_start
        if(fsm.input[THERMOSTAT]->state) {
          fsm.state_transition(START);
          id(controller_info).publish_state("Init complete. First state: START");
        } else {
          fsm.state_transition(IDLE);
          id(controller_info).publish_state("Init complete. First state: IDLE");
        }
        ESP_LOGD(fsm.state_name().c_str(), "INIT Complete first state: %s",fsm.state_name(fsm.get_next_state()).c_str());
        break;
      }
      case IDLE: {
        //DESCRIPTION: Does nothing until thermostat has a signal (after input delay)
        //INTERPRETS INPUTS: THERMOSTAT
        //RECEIVES EVENTS: THERMOSTAT ON
        //STATE TRANSITIONS: START;
        //SPECIAL: none
        if(fsm.input[THERMOSTAT]->state) {
          fsm.state_transition(START);
          ESP_LOGD(fsm.state_name().c_str(), "THERMOSTAT ON next state: START");
        }
        break;
      }
      case START: {
        //set target, with minimum of tracking value+2 to ensure compressor start
        if(oat < id(oat_silent_always_off).state) stooklijn_target_offset = -3;
        else if(oat < id(oat_silent_always_on).state) stooklijn_target_offset = -1;
        else if(oat > 15) stooklijn_target_offset = -3;
        else stooklijn_target_offset = -2;
        temp_new_target = id(stooklijn_target)+stooklijn_target_offset;
        ESP_LOGD(fsm.state_name().c_str(), "Run start initial target set; stooklijn_target: %f pendel_target: %f inlet: %f outlet: %f",id(stooklijn_target),temp_new_target,id(water_temp_aanvoer).state,id(water_temp_retour).state);
        run_start_time = run_time;
        state = STARTING;
        break;
      }
      case STARTING: {
        if(id(compressor_running).state){
          //we have ignition
          state = STABILIZE;
          compressor_time = run_time;
        }
        break;
      }
      case STABILIZE: {
        //check how far we are in the run
        if( (fsm.get_run_time() - fsm.get_run_start_time()) > (15*60) || ((fsm.get_run_time() - fsm.get_run_start_time()) > (6*60) && compressor_modulation)){
          //monitor situation
          //we are stable if derivative => -3 and <= 3 (1 degree in 20 minutes) or if compressor starts modulation (after 6 minutes)
           if(compressor_modulation || ((derivative_D_10 * 60) >= -3 && (derivative_D_10 * 60) <= 3)){
            //hand over to run algoritm, run will decide on overshoot/undershoot depending on where we stabilized
            ESP_LOGD(fsm.state_name().c_str(),"Stabilized, RUN is next");
            state = RUN;
            break;
          }
        }
        //else still early run
        //update target if tracking_value or stooklijn_target changed. No advanced modulation as this is useless during early run
        //limit number of updates to once every 5 minutes, unless run will be killed
        if((run_time - target_change_time) > (5*60)){
          if(delta > 0){
            temp_new_target = max(id(stooklijn_target)+stooklijn_target_offset,(float)tracking_value-4);
            temp_new_target = min(temp_new_target,id(stooklijn_target)+max_overshoot);
          }
        }
        break;
      }
      case RUN: {
        //check if we are running on the actual target
        if(temp_new_target != id(stooklijn_target)){
          //target changed, or stabilized on a different target
          if(temp_new_target < id(stooklijn_target)) {
            ESP_LOGD(fsm.state_name().c_str(),"Not running on stooklijn_target: new state will be stall");
            state = STALL;
            break;
          } else {
            ESP_LOGD(fsm.state_name().c_str(),"Not running on stooklijn_target: new state will be overshoot");
            state = OVERSHOOT;
            break;
          }
        }

        //when we are here, it means we where in a stable condition running on stooklijn_target
        //check if overshooting predicted, or if operating > 2 degrees below target (stall)
        //check predicted delta to reach in 20 minutes (pred_20_delta_5 and pred_20_delta_10)
        //first check if emergency condition (should not be the case but...)
        if(pendel_delta >= hysteresis){
          state = OVERSHOOT;
          break;
        }
        //then check if we have been in the current state for at least 5 minutes (to prevent over control)
        if((run_time - state_change_time) < (5*60)) break;
        //then check the predicted overshoot
        if(delta >= 1 && (pred_20_delta_5 >= 2.5 || pred_20_delta_10 >= 2.5)){
          //start overshooting algoritm to bring temperature back
          ESP_LOGD(fsm.state_name().c_str(),"New state will be overshoot. target: %f stooklijn_target: %f delta: %f pred_20_delta_5: %f pred_20_delta_10: %f",temp_new_target,id(stooklijn_target),delta,pred_20_delta_5,pred_20_delta_10);
          state = OVERSHOOT;
          break;
        } else if(delta <= -2 || (delta <= -1 && (pred_20_delta_5 < -3 || pred_20_delta_10 < -3))){
          //stall, or stall predicted
          ESP_LOGD(fsm.state_name().c_str(),"New state will be stall. target: %f stooklijn_target: %f delta: %f pred_20_delta_5: %f pred_20_delta_10: %f",temp_new_target,id(stooklijn_target),delta,pred_20_delta_5,pred_20_delta_10);
          state = STALL;
          break;
        } //else status quo       
        break;
      }
      case OVERSHOOT: {
        //overshooting logic
        //logic to contain overshoot and then return back to target
        if(delta < 1 && pred_20_delta_5 < 1.5 && pred_20_delta_10 < 1.5 ){
          //delta within range, are we done?
          if(temp_new_target <= id(stooklijn_target)){
            //overshoot contained operating below or at target
            //hand back to RUN at target
            temp_new_target = id(stooklijn_target);
            ESP_LOGD(fsm.state_name().c_str(), "stooklijn_target <= pendel_target, delta < 2, no overshoot predicted, my job is done.");
            state = RUN;
            break;
          }
        }
        if(pendel_delta >= hysteresis){
          //emergency situation, run is about to be killed. Raise Target to prevent
          temp_new_target = min(temp_new_target + 1,id(stooklijn_target) + max_overshoot);
          ESP_LOGD(fsm.state_name().c_str(), "Emergency intervention, raised pendel_target (%f) (if there was room)",temp_new_target);
          break;
        }
        if(temp_new_target > id(stooklijn_target)){
          //target overshoot logic to return to target
          //check if target can be lowered without killing the run
          if(pendel_delta <= hysteresis-1){
            //lower target, but not below id(stooklijn_target) next step may do that if needed
            temp_new_target = max(id(stooklijn_target),temp_new_target - 1);
            ESP_LOGD(fsm.state_name().c_str(), "Operating above stooklijn_target pendel_target (%f) could be lowered",temp_new_target);
            break;
          }
        }
        ESP_LOGD(fsm.state_name().c_str(), "waiting for (predicted)delta to come within rage delta: %f, pred_20_delta_5: %f, pred_20_delta_10: %f",delta,pred_20_delta_5,pred_20_delta_10);
        break;
      }
      case STALL: {
        //Stall! Stall! Stall, I have control
        //Logic to raise target to return back to stooklijn_target (and hopefully prevent overshoot)
        
        //1: check if recovered
        if(temp_new_target >= id(stooklijn_target) && delta >= 0 && pred_20_delta_5 >= 0 && pred_20_delta_10 >= 0){
          //target is no longer below stooklijn_target. No longer a stall
          //return to target and call run 
          temp_new_target = id(stooklijn_target);
          ESP_LOGD(fsm.state_name().c_str(), "delta > 0, stooklijn_target >= pendel_target, my job is done.");
          state = RUN;
          break;
        }
        //always give it at least 10 minutes
        if((run_time - target_change_time) < (10*60)) {
          ESP_LOGD(fsm.state_name().c_str(), "Stall is waiting for effect of previous target change");
          break;
        }

        //2: check if operating below stooklijn_target and fix it
        if(temp_new_target < id(stooklijn_target)){
          //is it bad?
          if((delta + (derivative_D_5*30)) < 0){
            //it will not be fixed next 30 minutes, take a big step
            //current target + 3 or tracking value, whichever is higher
            temp_new_target = max(tracking_value,temp_new_target + 3); 
          } else {
            //current target + 1 or tracking value, whichever is higher
            temp_new_target = max(tracking_value,temp_new_target  + 1);
          }
          //but not above stooklijn_target (yet)
          temp_new_target = min(id(stooklijn_target),temp_new_target);
          ESP_LOGD(fsm.state_name().c_str(), "Operating below target, raising target, pendel_target: %f",temp_new_target);
          break;
        }
        //3: We are operating at target, are we modulating?
        if(compressor_modulation && temp_new_target < id(stooklijn_target)+3){
          //raise target above stooklijn target to stop modulation
          temp_new_target = min(id(stooklijn_target)+3,tracking_value + 3);
          ESP_LOGD(fsm.state_name().c_str(), "Modulating, raising target, pendel_target: %f",temp_new_target);
          break;
        }
        //4 We are above target and with no modulation, so those tricks are gone. How bad is it?
        if((delta + (derivative_D_5*30)) < 0){
          //it will still not be fixed next 30 minutes
          if(oat < id(backup_heater_active_temp).state && !id(relay_backup_heat).state){
            id(relay_backup_heat).turn_on();
            id(controller_info).publish_state("STALL backup heat on");
            ESP_LOGD(fsm.state_name().c_str(), "tracking_value stalled, switched backup_heater on");
          }
          break;  
        }
        //Waiting for delta te become within range
        ESP_LOGD(fsm.state_name().c_str(), "Stall is waiting for next action (or out of options).");
        break;
      }
      case WAIT: {
        //check if value changed
        if(prev_stooklijn_target != id(stooklijn_target)) {
          temp_new_target = id(stooklijn_target);
          ESP_LOGD(fsm.state_name().c_str(),"Target changed: Setting new target: %f",temp_new_target);
        }
        
        //wait at least 6 minutes before switching to run, even if compressor is running
        if((run_time - state_change_time) < (6*60)) break;
                
        if(id(compressor_running).state){
          state = RUN;
          break;
        }
        break;
      }
      case SWW:
        if(prev_state != SWW){
          if(id(relay_backup_heat).state) id(controller_info).publish_state("Starting SWW with backup heat.");
          else if(id(relay_backup_heat).state) id(controller_info).publish_state("Starting SWW with no backup heat.");
        }
        if(!id(sww_heating).state){
          if(!thermostat_state){
            //straight off if no thermostat signal after SWW
            state = AFTERRUN;
            break;
          } else {
            state = (id(compressor_running).state) ? RUN : WAIT;
            //start boost if we were running without backup heat
            if(!id(relay_backup_heat).state){
              if(oat > id(backup_heater_active_temp).state) id(boost_switch).turn_on();
              id(controller_info).publish_state("SWW done starting boost.");
            }
            temp_new_target = id(stooklijn_target);
            break;
          }
        } 
        break;
      case DEFROST: {
        //first run only
        if(prev_state != DEFROST){
          if(id(relay_backup_heat).state) id(controller_info).publish_state("DEFROST backup heat on.");
          else id(controller_info).publish_state("DEFROST backup heat off.");
        }
        if(!id(defrosting).state){
          //defrosting stopped initially start with stooklijn_target as target
          if(temp_new_target != id(stooklijn_target)) temp_new_target = id(stooklijn_target);
          //10 minute delay (defrost takes 4 minutes) some additional delay to allow values to stabilize and backup heater to run
          if((run_time - state_change_time) < (10*60)) break;
          if(!thermostat_state){
            //straight off if no thermostat signal after defrost
            state = AFTERRUN;
            break;
          }
          if(id(compressor_running).state){
            if(delta > 0){
              if(id(relay_backup_heat).state) id(relay_backup_heat).turn_off();
              state = RUN;
            } else state = STALL;
          } else state = WAIT;
          if(id(relay_backup_heat).state) id(controller_info).publish_state("DEFROST done backup heat still on.");
          else id(controller_info).publish_state("DEFROST done backup heat off.");
        }
        break;
      }
      case AFTERRUN: {
        if((run_time - state_change_time) < (id(external_pump_runover).state*60)) break;
        state = IDLE;
        break;
      }
    }

    if(fsm.run_time() % alive_timer == 0){
      ESP_LOGD(fsm.state_name().c_str(), "**alive** timer: %d oat: %f inlet: %f outlet: %f tracking_value: %f stooklijn: %f pendel: %f delta: %f pendel_delta: %f ",fsm.run_time(),id(buiten_temp).state,id(water_temp_retour).state,id(water_temp_aanvoer).state,tracking_value,id(stooklijn_target),temp_new_target,delta,pendel_delta);
    }
    //***************************************************************
    //*******************Control/Thermostat/Relay/Heat logic*********
    //***************************************************************
    
    //check for SWW run
    if(id(sww_heating).state && state != SWW){
      ESP_LOGD(fsm.state_name().c_str(),"Detected SWW run");
      state = SWW;
    }
    
    //check for defrosting
    if(id(defrosting).state && state != DEFROST){
      ESP_LOGD(fsm.state_name().c_str(),"Detected defrosting");
      state = DEFROST;
    }
    
    
    //switch off
    if(state != INIT && state != IDLE && state != STABILIZE && state != SWW && state != DEFROST && state != AFTERRUN){
      if(!thermostat_state){
        ESP_LOGD(fsm.state_name().c_str(),"Detected valid switch off request");
        state = AFTERRUN;
      }
    } else if(thermostat_state && state != INIT && state == IDLE || state == AFTERRUN){
      state = START;
    }

    if(id(relay_heat).state){
      if(state == IDLE || state == AFTERRUN){
        id(relay_heat).turn_off();
        ESP_LOGD(fsm.state_name().c_str(),"Relay heat off due to incompatible state");
        id(controller_info).publish_state("Switching heat off due to incompatible state");
      } else if(!thermostat_state && state == SWW || state == DEFROST){
        id(relay_heat).turn_off();
        ESP_LOGD(fsm.state_name().c_str(),"Relay heat off due to thermostat switchoff during defrost/SWW");
        id(controller_info).publish_state("Switching heat off due to thermostat");
      }
    } else if(state == START || state == STARTING) {
      id(relay_heat).turn_on();
    } else if(thermostat_state && state == SWW || state == DEFROST){
      id(relay_heat).turn_on();
    }
    
    //check for a failed run (waiting)
    if(!id(compressor_running).state && id(relay_heat).state && (state == STABILIZE || state == RUN || state == OVERSHOOT || state == STALL)){
      ESP_LOGD(fsm.state_name().c_str(),"Failed run detected");
      state = WAIT;
    }

    //***************************************************************
    //*******************Silent mode logic***************************
    //***************************************************************
    //if oat >= silent always on: silent on
    //if oat <= silent always off: silent off
    //if in between: if boost or stall silent off otherwise silent on

    if(oat >= id(oat_silent_always_on).state) {
      if(!id(silent_mode).state){
        ESP_LOGD(fsm.state_name().c_str(),"oat > oat_silent_always_off and silent mode off, switching silent mode on");
        id(silent_mode_switch).turn_on();
        id(silent_mode).publish_state(true);
        id(controller_info).publish_state("Switching Silent mode on oat > on");
      }
    } else if(oat <= id(oat_silent_always_off).state){
      if(id(silent_mode).state){
        ESP_LOGD(fsm.state_name().c_str(),"Oat < oat_silent_always_on Switching silent mode off");
        id(controller_info).publish_state("Switching silent mode off oat < oat_silent_always_off");
        id(silent_mode_switch).turn_off();
        id(silent_mode).publish_state(false);
      }
    } else {
      if(boost || state == STALL){
        if(id(silent_mode).state){
          ESP_LOGD(fsm.state_name().c_str(),"Boost or stall silent mode off");
          id(controller_info).publish_state("STALL/Boost switching silent mode off");
          id(silent_mode_switch).turn_off();
          id(silent_mode).publish_state(false);
        }
      } else {
        ESP_LOGD(fsm.state_name().c_str(),"oat between silent mode brackers. No boost/stall switching silent off");
        id(controller_info).publish_state("Switching silent mode off oat in between");
        id(silent_mode_switch).turn_off();
        id(silent_mode).publish_state(false);
      }
    }
    if(id(silent_mode).state && id(compressor_rpm).state <= 50) compressor_modulation = true;
    else if(!id(silent_mode).state && id(compressor_rpm).state <= 70) compressor_modulation = true;
    else compressor_modulation = false;

    //***************************************************************
    //*******************Backup Heater logic*************************
    //***************************************************************

    //Switch off in these cases
    if(id(relay_backup_heat).state){
      if(state == INIT || state == IDLE || state == START || state == STARTING || state == OVERSHOOT || state == AFTERRUN){
        //incompatible state
        id(relay_backup_heat).turn_off();
        ESP_LOGD(fsm.state_name().c_str(),"Backup heat off due to incompatible state");
        id(controller_info).publish_state("Backup heat off due to state change");
      } else if(oat > id(backup_heater_active_temp).state){
        //temperature above limit
        id(relay_backup_heat).turn_off();
        ESP_LOGD(fsm.state_name().c_str(),"Backup heat off oat > backup_heater_active_temp");
        id(controller_info).publish_state("Backup heat off due to high oat");
      } else if(!id(relay_heat).state){
        //no heat request, why is backup heat on? (probably due to SWW?
        id(relay_backup_heat).turn_off();
        ESP_LOGD(fsm.state_name().c_str(),"Backup heat off no heat request (relay_heat off)");
        id(controller_info).publish_state("Backup heat off due to no heat request");
      } else if(backup_heat_cop_limit_trigger && average_cop > 0.0 && average_cop > (backup_heater_cop_limit+0.2) ){
        //if triggered due to low cop and situation improved (with some hysteresis)
        id(relay_backup_heat).turn_off();
        ESP_LOGD(fsm.state_name().c_str(),"Backup heat off no cop improved");
        id(controller_info).publish_state("Backup heat off due to cop improvement");
        backup_heat_cop_limit_trigger = false;
      }
    } else {
      backup_heat_cop_limit_trigger = false; //reset value
      //switch on in case of low average cop (for at least 15 minutes)
      if( (state == RUN || state == STALL)&&(oat <= id(backup_heater_active_temp).state && average_cop > 0.0 && average_cop < backup_heater_cop_limit && id(cop_guess).state < 2) ){
        //do not switch on if last switch off was not at least 10 minutes ago.
        if(run_time - backup_heat_change_time > (15*60)){
          id(relay_backup_heat).turn_on();
          backup_heat_cop_limit_trigger = true;
          id(controller_info).publish_state("Backup heat on due to low COP");
        }
      }
      //when first entering SWW mode or when thermostat switched on during SWW run
      if(state == SWW && (prev_state != SWW || (thermostat_state && prev_thermostat_state != thermostat_state))){
        if(oat <= id(backup_heater_active_temp).state && thermostat_state) id(relay_backup_heat).turn_on();
      }
      //when first entering defrost
      if(state == DEFROST && (prev_state != DEFROST || (thermostat_state && prev_thermostat_state != thermostat_state))){
        if(oat <= id(backup_heater_active_temp).state && thermostat_state) id(relay_backup_heat).turn_on();
      }
    }
    //backup heater will be turned on and off by SWW, DEFROST and sometimes STALL

    //***************************************************************
    //*******************External Pump logic*************************
    //***************************************************************
    //make sure external pump is running when backup heat and/or relay_heat is on
    //and during afterrun
    if(id(relay_backup_heat).state||id(relay_heat).state||state == AFTERRUN){
      if(!id(relay_pump).state){
        id(relay_pump).turn_on();
        ESP_LOGD(fsm.state_name().c_str(),"Exernal pump switched on.");
        id(controller_info).publish_state("External pump on.");
      }
    } else if(id(relay_pump).state){
      id(relay_pump).turn_off();
      ESP_LOGD(fsm.state_name().c_str(),"Exernal pump switched off.");
       id(controller_info).publish_state("External pump off.");
    }
   
    //***************************************************************
    //*******************Handle other Events*************************
    //***************************************************************
        
    //if internal pump running calculate derivative (if pump is not running, this value does not make sense).
    if(id(pump_running).state && state != SWW && state != DEFROST){
      //calculate derivative
      calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
    } else if(!id(pump_running).state && derivative.size() > 0){
      //if pump not running and derivative has values clear it
      derivative.clear();
      id(derivative_value).publish_state(0);
    }
    //if running for heating record COP
    if(state == STABILIZE || state == RUN || state == OVERSHOOT || state == STALL){
      float current_cop = id(cop_guess).state;
      //prevent invalid readings
      if(current_cop > 0.5) cop_vector.push_back(current_cop);
      //limit size to 30 elements(15 minutes)
      if(cop_vector.size() > 31) cop_vector.erase(cop_vector.begin());
      if(cop_vector.size() > 10) {
        //after at least 10 readings
        std::vector<float>::iterator it;
        float it_total = 0;
        for(it = cop_vector.begin(); it != cop_vector.end(); it++){
          it_total += *it;
        }
        average_cop = it_total/cop_vector.size();
        id(average_cop_sensor).publish_state(average_cop);
      }
    } else {
      cop_vector.clear();
      average_cop = 0;
      id(average_cop_sensor).publish_state(0);
    }
    
    //make sure there is always a prediction even with derivative = 0
    pred_20_delta_5 = (tracking_value + (derivative_D_5*20)) - id(stooklijn_target);
    pred_20_delta_10 = (tracking_value + (derivative_D_10*20)) - id(stooklijn_target);
    pred_5_delta_5 = (tracking_value + (derivative_D_5*5))- id(stooklijn_target);

    //check boost (raising the stooklijn with 2 degrees for xx minutes)
    if(id(boost_switch).state){
      //already in boost mode?
      if(boost){
        //yes, check time
        if(run_time - boost_start_time > (id(boost_time).state*60)){
          //expired, stop boost
          boost = false;
          id(boost_switch).turn_off();
          id(boost_active).publish_state(false);
          boost_offset = 0;
          id(update_stooklijn) = true;
          id(controller_info).publish_state("Boost mode deactivated");
        } 
      } else {
        //no, start boost mode
        boost = true;
        id(boost_active).publish_state(true);
        boost_start_time = run_time;
        boost_offset = 2;
        id(update_stooklijn) = true;
        id(controller_info).publish_state("Boost mode active");
      }
    } else {
      //boost switched off, did we know this?
      if(boost){
        //no we did not
        boost = false;
        id(boost_active).publish_state(false);
        boost_offset = 0;
        id(update_stooklijn) = true;
        id(controller_info).publish_state("Boost mode deactivated");
      }
    }
   
    if(id(stooklijn_target) != prev_stooklijn_target){
      //value changed, recalculate delta;
      ESP_LOGD(fsm.state_name().c_str(),"Stooklijn target changed, recalculating delta.");
      delta = tracking_value-id(stooklijn_target);
    }
    

    //***************************************************************
    //*******************Post Run Cleanup****************************
    //***************************************************************
    //Update modbus target if temp_new_target has changed    
    if((float)temp_new_target != (float)id(doel_temp).state && state != INIT){
      //prevent update while still in INIT
      //Update target through modbus
      set_target_temp(temp_new_target);
      id(doel_temp).publish_state(temp_new_target*10);
      target_change_time = run_time;
    }

    //Keep track of state changes
    if(state != prev_state){
      id(controller_state).publish_state(fsm.state_name());
      state_change_time = run_time;
      prev_state = state;
      ESP_LOGD(fsm.state_name().c_str(),"State change: %s",fsm.state_name().c_str());
    }

    //keep track of stooklijn_target changes
    if(prev_stooklijn_target != id(stooklijn_target)) prev_stooklijn_target = id(stooklijn_target);
    //keep track of backup_heater state changes
    if(prev_backup_heater_state != id(relay_backup_heat).state){
      prev_backup_heater_state = id(relay_backup_heat).state;
      backup_heat_change_time = run_time;
    }

    //NOW unflag all input values to be able to track changes on next run
    fsm.unflag_input_values();

    return;