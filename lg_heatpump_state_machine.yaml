lambda: !lambda |-
    
    //State machine, main algoritm that runs every 'clock' cycle
    //INIT: Initial startup (very early after boot)
    //IDLE: No heat request, wait for thermostat on
    //START: Set values and start HP
    //STARTING: Early start, temporary state (waiting for compressor start)
    //STABILIZE: Early in the run < 20 minutes of compressor time or not stable yet
    //RUN: HP operating with target = stooklijn_target (+/- 1 ) and no intervention. Decides on intevention (STALL, OVERSHOOT)
    //OVERSHOOT: Raising target above stooklijn_target to prevent compressor stop, should return to RUN when done
    //STALL: Temperature below target, returns to RUN when within limits
    //WAIT: Compressor has stopped during run with still heating request (so algoritm failed)
    //SWW: HP operating to create hot water
    //DEFROST: HP operating defrost cycle
    //HALT: shutdown (no more heat request)
    //AFTERRUN: Run done (no more heating request) external pump runs
    
    //state machine
    static States state = INIT;
    static States prev_state = INIT;
    static uint32_t run_time = 0; //total esp boot time
    static uint32_t run_start_time = 0; //run_time value upon start of heat run
    static uint32_t state_change_time = 0; //run_time value upon previous state change
    static uint32_t compressor_time = 0; //run_time value on last compressor start
    static uint32_t target_change_time = 0; //run_time value on last pendel_target change
    static uint32_t dt = round(id(state_machine).get_update_interval()/1000); //update interval in seconds
    static uint32_t boost_start_time = 0; //time since boost started (boost is raising the stooklijn by 2 degrees for 1 hour to bring temperature back)

    //configurable
    const static int hysteresis = 4; //Set controller control mode to 'outlet' and set hysteresis to the setting you have on the controller (recommend 4)
    const static int max_overshoot = 3; //maximum allowable overshoot in 'OVERSHOOT' state
    const float tracking_value = floor(id(water_temp_retour).state); //Set to value that anti-pendel script will track (outlet/inlet) (recommend inlet)
    const static int alive_timer = 120; //interval in seconds for an 'alive' message in the logs
        
    //control algoritm
    static std::vector<float> derivative; //vector of floats to integrate derivative (used in control logic)
    const float oat = round(id(buiten_temp).state); //outside air temperature
    static float temp_new_target = id(stooklijn_target); //anti-pendel target
    static float prev_stooklijn_target = id(stooklijn_target); //hold previous value of stooklijn target, to check for change
    float delta = tracking_value-id(stooklijn_target); //Current Error value negative below target, positive above target
    const float pendel_delta = tracking_value-temp_new_target; //Error value in regard to pendel target
    float derivative_D_5 = 0; //derivative based on past 5 minutes
    float derivative_D_10 = 0; //derivative based on past 10 minutes
    float pred_20_delta_5 = 0; //predicted delta in 20 minutes based on last 5 minute derivative
    float pred_20_delta_10 = 0; //predicted delta in 20 minutes based on last 10 minute derivative
    float pred_5_delta_5 = 0; //predicted delta in 5 minutes based on last 5 minute derivative
    static int stooklijn_target_offset = -3; //offset at start of run
    static int boost_offset = 0;
    static bool boost = false;

    run_time += dt;
    if(run_time % alive_timer == 0){
      ESP_LOGD(state_string[state], "**alive** timer: %d oat: %f inlet: %f outlet: %f tracking_value: %f stooklijn: %f pendel: %f delta: %f pendel_delta: %f ",run_time,id(buiten_temp).state,id(water_temp_retour).state,id(water_temp_aanvoer).state,tracking_value,id(stooklijn_target),temp_new_target,delta,pendel_delta);
    }

    //if delta >= 0 set silent mode unless oat < oat_silent_always_off
    if(delta >= 0 && oat > id(oat_silent_always_off).state && !id(silent_mode).state) {
      ESP_LOGD(state_string[state],"Delta > 0 and silent mode off, switching silent mode on");
      id(silent_mode_switch).turn_on();
    } else if(oat < id(oat_silent_always_off).state && id(silent_mode).state && state != SWW && state != START && state != STARTING && state != STABILIZE) {
      ESP_LOGD(state_string[state],"Oat < oat_silent_always_in Switching silent mode off");
      id(silent_mode_switch).turn_off();
    }
    
    //***************************************************************
    //************************ handle events ************************
    //***************************************************************
    //update stooklijn
    if(id(update_stooklijn)||state==INIT||state==START) {
      calculate_stooklijn();
      id(stooklijn_target) = id(stooklijn_target) + boost_offset;
    }
    if(id(stooklijn_target) != prev_stooklijn_target){
      //value changed, recalculate delta;
      ESP_LOGD(state_string[state],"Stooklijn target changed, recalculating delta.");
      delta = tracking_value-id(stooklijn_target);
    }

    //switch off check
    if(state != INIT && state != IDLE && state != STABILIZE && state != HALT && state != AFTERRUN){
      if(check_switch_off(state, run_time, run_start_time)){
        ESP_LOGD(state_string[state],"Detected valid switch off request");
        state = HALT;
      }
    }

    //if internal pump running calculate derivative (if pump is not running, this value does not make sense).
    if(id(pump_running).state && state != SWW && state != DEFROST){
      //calculate derivative
      calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
    } else if(!id(pump_running).state && derivative.size() > 0){
      //if pump not running and derivative has values clear it
      derivative.clear();
      id(derivative_value).publish_state(0);
    }
    //make sure there is always a prediction even with derivative = 0
    pred_20_delta_5 = (tracking_value + (derivative_D_5*20)) - id(stooklijn_target);
    pred_20_delta_10 = (tracking_value + (derivative_D_10*20)) - id(stooklijn_target);
    pred_5_delta_5 = (tracking_value + (derivative_D_5*5))- id(stooklijn_target);

    //check for a failed run (waiting)
    if(!id(compressor_running).state && id(relay_heat).state && (state == STABILIZE || state == RUN || state == OVERSHOOT || state == STALL)){
      ESP_LOGD(state_string[state],"Failed run detected");
      state = WAIT;
    }

    //check for SWW run
    if(id(sww_heating).state && state != SWW){
      ESP_LOGD(state_string[state],"Detected SWW run");
      state = SWW;
    }
    
    //check for defrosting
    if(id(defrosting).state && state != DEFROST){
      ESP_LOGD(state_string[state],"Detected defrosting");
      state = DEFROST;
    }

    //check boost (raising the stooklijn with 2 degrees for xx minutes)
    if(id(boost_switch).state){
      //already in boost mode?
      if(boost){
        //yes, check time
        if(run_time - boost_start_time > (id(boost_time).state*60)){
          //expired, stop boost
          boost = false;
          id(boost_switch).turn_off();
          id(boost_active).publish_state(false);
          boost_offset = 0;
        }
      } else {
        //no, start boost mode
        boost = true;
        id(boost_active).publish_state(true);
        boost_start_time = run_time;
        boost_offset = 2;
      }
    } else {
      //boost switched off, did we know this?
      if(boost){
        //no we did not
        boost = false;
        id(boost_active).publish_state(false);
        boost_offset = 0;
      }
    }
   
    if(id(stooklijn_target) != prev_stooklijn_target){
      //value changed, recalculate delta;
      ESP_LOGD(state_string[state],"Stooklijn target changed, recalculating delta.");
      delta = tracking_value-id(stooklijn_target);
    }
    //***************************************************************
    //***************************************************************

    switch (state) {
      case INIT: {
        //early start. Be patient until everything is set up
        if(run_time > 60 && !isnan(id(buiten_temp).state) && !isnan(id(water_temp_aanvoer).state) && !isnan(id(water_temp_retour).state) && !isnan(tracking_value)){
          id(derivative_value).publish_state(0);
          if(id(thermostat_signal).state) {
            state = START;
          } else {
            id(relay_heat).turn_off();
            id(relay_pump).turn_off();
            state = IDLE;
          }
        }
        break;
      }
      case IDLE: {
        if(id(thermostat_signal).state){
          state = START;
        } else {
          if(id(relay_heat).state) id(relay_heat).turn_off();
          if(id(relay_pump).state) id(relay_pump).turn_off();
        }
        break;
      }
      case START: {
        //wait for thermostat_on delay
        if((run_time - state_change_time) < (id(thermostat_on_delay).state*60)) break;
        //after delay:
        if(!id(thermostat_signal).state){
          //thermostat switched off during on delay timer
          state = IDLE;
          break;
        }
        //switch on external pump
        id(relay_pump).turn_on();
        temp_new_target = max((id(stooklijn_target)-3),((float)tracking_value+2)); //minimum of tracking value+2 to ensure compressor start
        if(oat < 0) stooklijn_target_offset = 0;
        else if(oat < 6) stooklijn_target_offset = -2;
        else if(oat < 15) stooklijn_target_offset = -3;
        else stooklijn_target_offset = -4;
        ESP_LOGD(state_string[state], "Run start initial target set; stooklijn_target: %f pendel_target: %f inlet: %f outlet: %f",id(stooklijn_target),temp_new_target,id(water_temp_aanvoer).state,id(water_temp_retour).state);
        run_start_time = run_time;
        //always start with silent on
        if(!id(silent_mode).state) id(silent_mode_switch).turn_on();
        //switch on heatpump external thermostat contact
        id(relay_heat).turn_on();
        state = STARTING;
        break;
      }
      case STARTING: {
        if(id(compressor_running).state){
          //we have ignition
          state = STABILIZE;
          compressor_time = run_time;
        }
        break;
      }
      case STABILIZE: {
        //always stabilize with silent on
        if(!id(silent_mode).state) id(silent_mode_switch).turn_on();
        //check how far we are in the run
        if((run_time - run_start_time) > (20*60)){
          //monitor situation
          //we are stable if derivative => -2 and <= 2 or if compressor starts modulation
           if(id(compressor_rpm).state <= 45 || ((derivative_D_10 * 60) >= -2 && (derivative_D_10 * 60) <= 2)){
            //hand over to run algoritm, run will decide on overshoot/undershoot depending on where we stabilized
            ESP_LOGD(state_string[state],"Stabilized, RUN is next");
            state = RUN;
            break;
          }
        } //else still early run
        //update target if tracking_value or stooklijn_target changed. No advanced modulation as this is useless during early run
        //limit number of updates to once every 5 minutes, unless run will be killed
        if((run_time - target_change_time) > (5*60) || delta >= hysteresis){
          temp_new_target = max(id(stooklijn_target)+stooklijn_target_offset,(float)tracking_value-2);
          temp_new_target = min(temp_new_target,id(stooklijn_target)+max_overshoot);
        }
        break;
      }
      case RUN: {
        //check if we are running on the actual target
        if(temp_new_target != id(stooklijn_target)){
          //target changed, or stabilized on a different target
          if(temp_new_target < id(stooklijn_target)) {
            ESP_LOGD(state_string[state],"Not running on stooklijn_target: new state will be stall");
            state = STALL;
            break;
          } else {
            ESP_LOGD(state_string[state],"Not running on stooklijn_target: new state will be overshoot");
            state = OVERSHOOT;
            break;
          }
        }else {
          //when we are here, it means we where in a stable condition running on stooklijn_target
          //check if overshooting predicted, or if operating > 2 degrees below target (stall)
          //check predicted delta to reach in 20 minutes (pred_20_delta_5 and pred_20_delta_10)
          //first check if emergency condition (should not be the case but...)
          if(pendel_delta >= hysteresis){
            state = OVERSHOOT;
            break;
          }
          //then check if we have been in the current state for at least 5 minutes (to prevent over control)
          if((run_time - state_change_time) < (5*60)) break;
          //then check the predicted overshoot
          if(delta >= 2 && (pred_20_delta_5 >= 3 || pred_20_delta_10 >= 3)){
            //start overshooting algoritm to bring temperature back
            ESP_LOGD(state_string[state],"New state will be overshoot. target: %f stooklijn_target: %f delta: %f pred_20_delta_5: %f pred_20_delta_10: %f",temp_new_target,id(stooklijn_target),delta,pred_20_delta_5,pred_20_delta_10);
            state = OVERSHOOT;
            break;
          } else if(delta <= -2.5 || (delta <= -1 && (pred_20_delta_5 < -3 || pred_20_delta_10 < -3))){
            //stall, or stall predicted
            ESP_LOGD(state_string[state],"New state will be stall. target: %f stooklijn_target: %f delta: %f pred_20_delta_5: %f pred_20_delta_10: %f",temp_new_target,id(stooklijn_target),delta,pred_20_delta_5,pred_20_delta_10);
            state = STALL;
            break;
          } //else status quo
        }       
        break;
      }
      case OVERSHOOT: {
        //overshooting logic
        //logic to contain overshoot and then return back to target
        if(delta < 2 && pred_20_delta_5 < 2 && pred_20_delta_10 < 2 ){
          //delta within range, are we done?
          if(temp_new_target <= id(stooklijn_target)){
            //overshoot contained operating below or at target
            //hand back to RUN at target
            temp_new_target = id(stooklijn_target);
            ESP_LOGD(state_string[state], "stooklijn_target <= pendel_target, delta < 2, no overshoot predicted, my job is done.");
            state = RUN;
            break;
          }
        }
        if(pendel_delta >= hysteresis){
          //emergency situation, run is about to be killed. Raise Target to prevent
          temp_new_target = min(temp_new_target + 1,id(stooklijn_target) + max_overshoot);
          ESP_LOGD(state_string[state], "Emergency intervention, raised pendel_target (%f) (if there was room)",temp_new_target);
          break;
        }
        if(temp_new_target > id(stooklijn_target)){
          //target overshoot logic to return to target
          //check if target can be lowered without killing the run
          if(pendel_delta <= hysteresis-1){
            //lower target, but not below id(stooklijn_target) next step may do that if needed
            temp_new_target = max(id(stooklijn_target),temp_new_target - 1);
            ESP_LOGD(state_string[state], "Operating above stooklijn_target pendel_target (%f) could be lowered",temp_new_target);
            break;
          }
        }
        if(delta >= 2 || pred_20_delta_5 > 2 || pred_20_delta_10 > 2 ){
          //we are operating at or below stooklijn_target with actual or predicted overshoot, but no emergency
          //see if we intervene or just monitor
          if(pred_20_delta_5 > 2 || pred_20_delta_10 > 2){
            //lower target, but not below stooklijn_target - 3
            //limit number of updates to once every 5 minutes. Don't update if already sufficient downward trend
            if((run_time - target_change_time) > (5*60) && (derivative_D_5*60) > -2){
              temp_new_target = max(temp_new_target - 1,id(stooklijn_target)-3);
              ESP_LOGD(state_string[state], "Overshoot active or predicted, lowered pendel_target: %f",temp_new_target);
              break;
            }
          }
        }
        ESP_LOGD(state_string[state], "waiting for (predicted)delta to come within rage delta: %f, pred_20_delta_5: %f, pred_20_delta_10: %f",delta,pred_20_delta_5,pred_20_delta_10);
        break;
      }
      case STALL: {
        //Stall! Stall! Stall, I have control
        //Logic to raise target to return back to stooklijn_target (and hopefully prevent overshoot)
        
        //1: check if recovered
        if(temp_new_target >= id(stooklijn_target) && delta >= 0 && pred_20_delta_5 >= 0 && pred_20_delta_10 >= 0){
          //target is no longer below stooklijn_target. No longer a stall
          //return to target and call run 
          temp_new_target = id(stooklijn_target);
          ESP_LOGD(state_string[state], "delta > 0, stooklijn_target >= pendel_target, my job is done.");
          state = RUN;
          break;
        }
        //2: check if on the way to rcovery
        if((derivative_D_5*60) > 4){
          //temperature is increasing (1 degree per 15 minutes), keep target, but make sure it is not less than tracking_value - hysteresis + 1
          temp_new_target = max(temp_new_target, tracking_value-hysteresis+1);
          temp_new_target = min(temp_new_target,id(stooklijn_target));
          ESP_LOGD(state_string[state], "tracking_value still increasing > 4, pendel_target: %f",temp_new_target);
          break;
        }
        //3: check if operating below stooklijn_target and fix it
        if((derivative_D_5*60) >= 2){
          //temperature raising slowly (0.5 degree per 15 minutes) increase target, but not above stooklijn
          if((run_time - target_change_time) > (10*60))
          temp_new_target = min(id(stooklijn_target),temp_new_target  + 1);
          ESP_LOGD(state_string[state], "tracking_value still increasing < 4 > 2, pendel_target: %f",temp_new_target);
          break;
        }
        //4: check if silent mode needs to come off
        if((temp_new_target >= (id(stooklijn_target)+3)||(temp_new_target == id(stooklijn_target) && delta < -2)) && (run_time - target_change_time > (10*60))){
          //rise is quite slow and target can not be raised further. Patience or intervention?
          //check if prediction indicated downtrent and check if compressor is not modulated
          if(id(silent_mode).state && (pred_20_delta_5 < 0 || pred_20_delta_10 < 0) && id(compressor_rpm).state > 50){
            //intervention
            id(silent_mode_switch).turn_off();
            ESP_LOGD(state_string[state], "tracking_value stalled, switched silent mode off");
            break;
          }
        }
        //5: raise target above stooklijn_target (to stop modulation)
        //derivative is low and there is room to raise (and raising may help)
        if((run_time - target_change_time) > (10*60)){
          temp_new_target = min(id(stooklijn_target)+3,temp_new_target + 1);
          ESP_LOGD(state_string[state], "tracking_value (almost) static, but room to raise pendel_target: %f",temp_new_target);
          break;
        }
        //Waiting for delta te become within range
        ESP_LOGD(state_string[state], "Stall is waiting for next action.");
        break;
      }
      case WAIT: {
        //check if value changed
        if(prev_stooklijn_target != id(stooklijn_target)) {
          temp_new_target = id(stooklijn_target);
          ESP_LOGD(state_string[state],"Target changed: Setting new target: %f",temp_new_target);
        }
        
        //wait 10 minutes to allow compressor to start and temperatures to stabilize
        if((run_time - state_change_time) < (10*60)) break;
                
        if(id(compressor_running).state){
          if(prev_state == SWW){
            id(boost_switch).turn_on();
            //silent mode boost
            if( id(silent_mode).state && (oat < id(oat_silent_always_off).state ||(oat <= id(oat_silent_boost).state && delta < -3))){
              id(silent_mode_switch).turn_off();
            }
          }
          state = RUN;
          break;
        }
        //No compressor after 10 minutes. Force idle or restart (start will set target @ tracking value-2)
        state = id(thermostat_signal).state ? START : IDLE;
        break;
      }
      case SWW:
        if(oat > id(oat_silent_always_off).state && !id(silent_mode).state) id(silent_mode_switch).turn_on();
        if(!id(sww_heating).state){
          //sww run stopped
          if(!id(thermostat_signal).state){
            state = IDLE;
            break;
           } else {
            state = (id(compressor_running).state) ? RUN : WAIT;
            temp_new_target = id(stooklijn_target);
            break;
          }
        }
        break;
      case DEFROST: {
        if(!id(defrosting).state){
          //defrosting stopped initially start with stooklijn_target as target
          if(temp_new_target != id(stooklijn_target)) temp_new_target = id(stooklijn_target);
          //9 minute delay (defrost takes 4 minutes) some additional delay to allow values to stabilize
          if((run_time - state_change_time) < (9*60)) break;
          if(!id(thermostat_signal).state){
            state = IDLE;
            break;
          }
          //after delay time, check current target and decide on silent mode
          if( id(silent_mode).state && ( oat < id(oat_silent_always_off).state||(delta < -2 && oat < id(oat_silent_boost).state) ) ) id(silent_mode_switch).turn_off();
          else if(!id(silent_mode).state) id(silent_mode_switch).turn_on(); 
          state = id(compressor_running).state ? RUN : WAIT;
        }
        break;
      }
      case HALT: {
        //wait for thermostat_off delay
        if((run_time - state_change_time) < (id(thermostat_off_delay).state*60)) break;
        //after delay:
        if(id(thermostat_signal).state){
          //thermostat reset, so continue operation
          state = RUN;
          break;
        }
        //thermostat not switched on again, so halt session
        id(relay_heat).turn_off();
        state = AFTERRUN;
        break;
      }
      case AFTERRUN: {
        if((run_time - state_change_time) < (id(external_pump_runover).state*60)) break;
        id(relay_pump).turn_off();
        state = IDLE;
        break;
      }
    }
        
    if((float)temp_new_target != (float)id(doel_temp).state){
      //Update target through modbus
      set_target_temp(temp_new_target);
      id(doel_temp).publish_state(temp_new_target*10);
      target_change_time = run_time;
    }
    
    if(state != prev_state){
      id(controller_state).publish_state(state_string_friendly[state]);
      state_change_time = run_time;
      prev_state = state;
      ESP_LOGD(state_string[state],"State change: %s",state_string[state]);
    }
    if(prev_stooklijn_target != id(stooklijn_target)) prev_stooklijn_target = id(stooklijn_target);
    return;