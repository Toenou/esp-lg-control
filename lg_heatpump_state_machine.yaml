lambda: !lambda |-
    
    //State machine, main algoritm that runs every 'clock' cycle
    //INIT: Initial startup (very early after boot)
    //IDLE: No heat request, wait for thermostat on
    //START: Set values and start HP
    //STARTING: Early start, temporary state (waiting for compressor start)
    //EARLYRUN: Early in the run < 15 minutes of compressor time
    //RUNNING: Running with target = stooklijn_target and no intervention
    //OVERSHOOTING: Raising target above stooklijn_target to prevent compressor stop, should return to RUNNING when done
    //UNDERSHOOTING: Setting a target under stooklijn_target to force modulation, should return to RUNNING when done
    //WAITING: Compressor has stopped during run with still heating request (so algoritm failed)
    //SWW: Running to create hot water
    //HALT: shutdown (no more heat request)
    //AFTERRUN: Run done (no more heating request) external pump runs
    
    //state machine
    static States state = INIT;
    static States prev_state = INIT;
    static uint32_t run_time = 0; //total esp boot time
    static uint32_t run_start_time = 0; //run_time value upon start of heat run
    static uint32_t state_change_time = 0; //run_time value upon previous state change
    static uint32_t compressor_time = 0; //run_time value on last compressor start
    static uint32_t dt = round(id(state_machine).get_update_interval()/1000); //update interval in seconds

    //configurable
    const static int hysteresis = 4; //Set controller control mode to 'outlet' and set hysteresis to the setting you have on the controller (recommend 4)
    const static int max_overshoot = 3; //maximum allowable overshoot in 'OVERSHOOTING' state
    const float tracking_value = id(water_temp_retour).state; //Set to value that anti-pendel script will track (outlet/inlet) (recommend inlet)
    const static int alive_timer = 120; //interval in seconds for an 'alive' message in the logs
        
    //control algoritm
    static std::vector<float> integral; //vector of floats to integrate error (used in control logic)
    static std::vector<float> derivative; //vector of floats to integrate derivative (used in control logic)
    const float oat = id(buiten_temp).state; //outside air temperature
    static float temp_new_target = id(stooklijn_target); //anti-pendel target
    const float delta = id(stooklijn_target)-tracking_value; //Current Error value
    const float pendel_delta = temp_new_target-tracking_value; //Error value in regard to pendel target
    float derivative_D_5 = 0; //derivative based on past 5 minutes
    float derivative_D_10 = 0; //derivative based on past 10 minutes
    
    run_time += dt;
    if(run_time % alive_timer == 0){
      ESP_LOGD(state_string[state], "**alive** timer: %d oat: %f inlet: %f outlet: %f stooklijn: %f pendel: %f delta: %f pendel_delta: %f ",run_time,id(buiten_temp).state,id(water_temp_retour).state,id(water_temp_aanvoer).state,id(stooklijn_target),temp_new_target,delta,pendel_delta);
    }

    //if delta <= 0 set silent mode unless oat < oat_silent_always_off
    if(delta <= 0 && oat > id(oat_silent_always_off).state && !id(silent_mode).state) id(silent_mode_switch).turn_on();
    
    //TODO check SWW
     
    if(!id(compressor_running).state){
      if(state != INIT && state != IDLE && state != START && state != STARTING && state != WAITING && state != HALT && state != AFTERRUN){
        //compressor not running, but it should be find out what happened
      } 
    } else {
      
    }

    switch (state) {
      case INIT: {
        //early start. Be patient until everything is set up
        if(run_time > 60 && !isnan(id(buiten_temp).state) && !isnan(id(water_temp_aanvoer).state) && !isnan(id(water_temp_retour).state) && !isnan(tracking_value)){
          calculate_stooklijn();
          if(id(thermostat_signal).state) {
            state = START;
          } else {
            id(relay_heat).turn_off();
            id(relay_pump).turn_off();
            state = IDLE;
          }
        }
        break;
      }
      case IDLE: {
        if(id(thermostat_signal).state){
          state = START;
        } else {
          if(id(relay_heat).state) id(relay_heat).turn_off();
          if(id(relay_pump).state) id(relay_pump).turn_off();
        }
        break;
      }
      case START: {
        //switch on external pump
        id(relay_pump).turn_on();
        //clear integral
        integral.clear();
        id(integral_value).publish_state(0);
        //clear derivative
        derivative.clear();
        id(derivative_value).publish_state(0);
        //Set initial target at stooklijn_target
        calculate_stooklijn();
        temp_new_target = id(stooklijn_target);
        //If OAT <= 3 and silent mode on and delta >= 3 set silent mode off
        //else set silent on
        id(after_defrost_script).stop();
        if(!id(sww_heating).state && oat > id(oat_silent_always_off).state && oat <= 3 && delta >= 3 && id(silent_mode).state) id(silent_mode_switch).turn_off();
        else id(silent_mode_switch).turn_on();
        ESP_LOGD(state_string[state], "Run start initial target set; stooklijn_target: %f pendel_target: %f inlet: %f outlet: %f",id(stooklijn_target),temp_new_target,id(water_temp_aanvoer).state,id(water_temp_retour).state);
        //switch on heatpump external thermostat contact
        id(relay_heat).turn_on();
        state = STARTING;
        run_start_time = run_time;
        if(check_switch_off(state, run_time, run_start_time)){
          state = HALT;
          break;
        }
        break;
      }
      case STARTING: {
        //switch off check
        if(check_switch_off(state, run_time, run_start_time)){
          state = HALT;
          break;
        }
        if(id(compressor_running).state){
          //we have ignition
          state = EARLYRUN;
          compressor_time = run_time;
        }
        break;
      }
      case EARLYRUN: {
        //no switch-off check as min_run_time has definately not passed
        //calculate derivative
        calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
        //check is stooklijn changed
        if(id(update_stooklijn)) calculate_stooklijn();
        //update target if value changed. No modulation as this is useless during early run
        if(temp_new_target != id(stooklijn_target)) temp_new_target = id(stooklijn_target);
        //check if early run finished
        if((run_time - state_change_time) > (15*60)) state = RUNNING;
        //check for a failed run (waiting)
        if(!id(compressor_running).state && id(relay_heat).state){
          state = WAITING;
        }
        break;
      }
      case RUNNING: {
        //switch off check
        if(check_switch_off(state, run_time, run_start_time)){
          state = HALT;
          break;
        }
        //calculate derivative
        calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
        //check if stooklijn changed
        if(id(update_stooklijn)) calculate_stooklijn();
        //check for failed run (set waiting)
        if(!id(compressor_running).state && id(relay_heat).state){
          state = WAITING;
          break;
        }
        //check if value changed
        if(temp_new_target != id(stooklijn_target)) {
          //if new target is lower, use overshooting algoritm to bring temp down
          //if new target is higher let HP handle it initially
          if(id(stooklijn_target) < temp_new_target) {
            ESP_LOGD(state_string[state],"Target changed: new state will be overshooting");
            state = OVERSHOOTING;
            break;
          } else temp_new_target = id(stooklijn_target);
          ESP_LOGD(state_string[state],"Target changed: Setting new target: %f",temp_new_target);
        }
        //check if overshooting, or overshoot predicted
        //overshooting is raising the pendel_target temporarily, allowing to 'overshoot' the stooklijn target
        //the aim is  to prevent the run from being stopped.
        //when an overshoot is predicted the system first tries to avoid by undershooting
        //undershooting is setting the pendel_target below the stooklijn target to force modulation
        //if undershooting does not prevent overshooting, the overschooting logic kicks in and tries to gently lower the
        //temperature back to the target
            
        //predicted temperature to reach in 20 minutes
        float pred_tracking_value_5 = tracking_value + (derivative_D_5*20);
        float pred_tracking_value_10 = tracking_value + (derivative_D_10*20);
        //predicted temperature to reach in 5 minutes
        float pred_5_tracking_value_5 = tracking_value + (derivative_D_5*5);
        //check if intervention needed
        //check if overshoot of more then 2 degrees is predicted in the next 20 minutes
        if(pred_tracking_value_5 > id(stooklijn_target)+2 && pred_tracking_value_10 > id(stooklijn_target)+2){
          //start undershooting to force HP into modulation
          temp_new_target = round(tracking_value)-hysteresis + 2;
          if(temp_new_target > id(stooklijn_target)){
            //intervention too late, straight to overshooting
            ESP_LOGD(state_string[state],"New state will be overshooting, new target: %f pred_D_5: %f pred_D_10: %f",temp_new_target,pred_tracking_value_5,pred_tracking_value_10);
            state = OVERSHOOTING;
            break;
          } else {
            ESP_LOGD(state_string[state],"New state will be undershooting, new target: %f pred_D_5: %f pred_D_10: %f",temp_new_target,pred_tracking_value_5,pred_tracking_value_10);
            state = UNDERSHOOTING;
          }
        }       
        break;
      }
      case OVERSHOOTING: {
        //switch off check
        if(check_switch_off(state, run_time, run_start_time)){
          state = HALT;
          break;
        }
        //calculate derivative
        calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
        //check if stooklijn changed
        //no action needed as overshooting will act considering actual stooklijn value
        if(id(update_stooklijn)) calculate_stooklijn();
        //check for failed run (set waiting)
        if(!id(compressor_running).state && id(relay_heat).state){
          state = WAITING;
          break;
        }
        //overshooting logic
        //logic to temporarily overshoot and then return back to target
        if((pendel_delta + hysteresis) <= 0 ){
          //run is about to be killed, raise target if there is still room
          temp_new_target = temp_new_target + 1;
          if(temp_new_target > id(stooklijn_target) + max_overshoot) temp_new_target = id(stooklijn_target) + max_overshoot;
          ESP_LOGD(state_string[state], "Overshooting: raised target (if there was room)");
        } else if(temp_new_target > id(stooklijn_target)){
          //check if target can be lowered without killing the run
          if(pendel_delta + (hysteresis-1) >= 0 ){
            temp_new_target = temp_new_target - 1;
          }
          ESP_LOGD(state_string[state], "Overshooting: checked if target could be lowered");
        } else {
          ESP_LOGD(state_string[state], "Overshooting: waiting for delta to become within rage");
        }
        if(temp_new_target <= id(stooklijn_target)){
          //all normal again
          temp_new_target = id(stooklijn_target);
          ESP_LOGD(state_string[state], "Overshooting: all normal next state will be running");
          state = RUNNING;
          break;       
        }        
        break;
      }
      case UNDERSHOOTING: {
        //switch off check
        if(check_switch_off(state, run_time, run_start_time)){
          state = HALT;
          break;
        }
        //calculate derivative
        calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
        //check if stooklijn changed
        //no action needed as undershooting will act considering actual stooklijn value
        if(id(update_stooklijn)) calculate_stooklijn();
        //undershooting, logic to force modulation and then raise the target back to stooklijn_target
        //check for failed run (set waiting)
        if(!id(compressor_running).state && id(relay_heat).state){
          state = WAITING;
        }
        if(pendel_delta <= 0-(hysteresis-1)){
          //increase target
          temp_new_target = temp_new_target + 1;
          //reset integral
          integral.clear();
          id(integral_value).publish_state(0);
          ESP_LOGD(state_string[state],"Undershooting: pendel_delta <= 0-(hysteresis-1) increased target.");
        } else if(pendel_delta <= 0){
          //temperature is more than pendel_target, but lower than pendel_target+(hysteresis-1)
          //this is ok as a transient condition, but stalling must be prevented
          //push current error into integral
          float integral_factor = 0.067; //1 degree 15 minutes
          if ((int)id(compressor_rpm).state < 20 || delta <= 0) integral_factor = 0.25; //1 degree 4 minutes
          else if ((int)id(compressor_rpm).state < 30) integral_factor = 0.1; //1 degree 10 minutes
          else if ((int)id(compressor_rpm).state > 50) integral_factor = 0.05; //1 degree 20 minutes
          float i_number = integral_factor;
          integral.push_back(i_number);
          //limit size to 20 elements
          if(integral.size() > 20) integral.erase(integral.begin());
          //check current integral error
          float integral_I = 0;
          for(auto it : integral){
            integral_I = integral_I + it;
          }
          ESP_LOGD(state_string[state],"Undershooting: pendel_delta <= 0 loaded integral. integral: %f",integral_I);
          //if integral error is more than 1 
          if(integral_I >= 1.0){
            temp_new_target = temp_new_target + 1;
            //clear integral
            integral.clear();
            integral_I = 0;
            ESP_LOGD(state_string[state],"Undershooting: integral >= 1 increased target.");
          } else if (integral_I < -1) {
            integral.clear();
            integral.push_back(-1);
            if(i_number > 0) integral.push_back(i_number);
            integral_I = -1;
          }
          id(integral_value).publish_state(integral_I);
        } else {
          //Waiting for delta te become within range
          ESP_LOGD(state_string[state], "Undershooting: waiting for temperature to reach next target.");
        }
        if(temp_new_target >= id(stooklijn_target)){
          //Run under control?
          float pred_5_tracking_value_5 = tracking_value + (derivative_D_5*5);
          if(pred_5_tracking_value_5 > id(stooklijn_target)+hysteresis || tracking_value > id(stooklijn_target)+hysteresis-1){
            //doest look under control, revert to overshooting
            ESP_LOGD(state_string[state], "Run not under control, next state overhooting.");
            state = OVERSHOOTING;
          } else {
            //hand back to normal control logic
            ESP_LOGD(state_string[state], "Run under control, next state running.");
            state = OVERSHOOTING;
          }
          integral.clear();
          id(integral_value).publish_state(0);          
        }        
        break;
      }
      case WAITING: {
        //switch off check
        if(check_switch_off(state, run_time, run_start_time)){
          state = HALT;
          break;
        }
        //calculate derivative
        calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
        //check if stooklijn changed
        if(id(update_stooklijn)) calculate_stooklijn();
        //check if value changed
        if(temp_new_target != id(stooklijn_target)) {
          temp_new_target = id(stooklijn_target);
          ESP_LOGD(state_string[state],"Target changed: Setting new target: %f",temp_new_target);
        }
        //wait for 5 minutes to see if compressor restarts
        if(id(compressor_running).state){
          state = RUNNING;
          break;
        }
        if((run_time - state_change_time) > (5*60)) {
          //restart
          state = START;
        }
        break;
      }
      case SWW:
        break;
      case HALT: {
        //1 minute delay
        if((run_time - state_change_time) < (60)) break;
        //after delay:
        if(id(thermostat_signal).state){
          //thermostat reset, so continue operation
          state = RUNNING;
          break;
        }
        id(relay_heat).turn_off();
        state = AFTERRUN;
        break;
      }
      case AFTERRUN: {
        if(run_time - state_change_time > (id(minimum_run_time).state*60)){
          id(relay_pump).turn_off();
          state = IDLE;
        }
        break;
      }
    }
        
    //Calculate new (anti pendel) target
    //Basic algorithm
    //System initializes at the start of a run (when working mode changes 2)
    //Then sets initial target to 'real' target minus 4. With a minimum of tracking_value + 2 to ensure compressor start.
    //Maximum value is 'real' target. 
    //When the compressor turns on the logic starts running, monitorring the overshoot of the temporary target
    //When the overshoot approaches hysteresis - 1 the temporary target is increased by 1 until temporary target == real target
    //When the temporary target equals the 'real' target temperature, or the tracking value equals the 'real' target the logic stops so the HP can take over again an run its own logic
    //System resets at heating mode stop (system working mode 0) for example when the room thermostat stops the heating or compressor restart with delta > 1.8
    //While the tracking value is above the temporary_target, but below the 'real' target an integral is loaded
    //Every time the integral hits the limit temporary_target is raised by 1.
    
    if((float)temp_new_target != (float)id(doel_temp).state){
      //Update target through modbus (set level needs value between 0-1, so divide by 100)
      set_target_temp(temp_new_target);
      //Update sensors
      id(pendel_watertemp_target).publish_state(temp_new_target);
      //id(doel_temp).publish_state(temp_new_target*10);
    }
    
    if(state != prev_state){
      id(controller_state).publish_state(state_string[state]);
      state_change_time = run_time;
      prev_state = state;
    }
    return;