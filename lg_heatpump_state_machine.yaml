lambda: !lambda |-
    
    //State machine, main algoritm that runs every 'clock' cycle
    //INIT: Initial startup (very early after boot)
    //IDLE: No heat request, wait for thermostat on
    //START: Set values and start HP
    //STARTING: Early start, temporary state (waiting for compressor start)
    //EARLYRUN: Early in the run < 15 minutes of compressor time
    //RUNNING: Running with target = stooklijn_target and no intervention
    //OVERSHOOTING: Raising target above stooklijn_target to prevent compressor stop, should return to RUNNING when done
    //UNDERSHOOTING: Setting a target under stooklijn_target to force modulation, should return to RUNNING when done
    //WAITING: Compressor has stopped during run with still heating request (so algoritm failed)
    //SWW: Running to create hot water
    //DEFROST: Running defrost cycle
    //HALT: shutdown (no more heat request)
    //AFTERRUN: Run done (no more heating request) external pump runs
    
    //state machine
    static States state = INIT;
    static States prev_state = INIT;
    static uint32_t run_time = 0; //total esp boot time
    static uint32_t run_start_time = 0; //run_time value upon start of heat run
    static uint32_t state_change_time = 0; //run_time value upon previous state change
    static uint32_t compressor_time = 0; //run_time value on last compressor start
    static uint32_t dt = round(id(state_machine).get_update_interval()/1000); //update interval in seconds

    //configurable
    const static int hysteresis = 4; //Set controller control mode to 'outlet' and set hysteresis to the setting you have on the controller (recommend 4)
    const static int max_overshoot = 3; //maximum allowable overshoot in 'OVERSHOOTING' state
    const float tracking_value = id(water_temp_retour).state; //Set to value that anti-pendel script will track (outlet/inlet) (recommend inlet)
    const static int alive_timer = 120; //interval in seconds for an 'alive' message in the logs
        
    //control algoritm
    static std::vector<float> integral; //vector of floats to integrate error (used in control logic)
    static std::vector<float> derivative; //vector of floats to integrate derivative (used in control logic)
    const float oat = id(buiten_temp).state; //outside air temperature
    static float temp_new_target = id(stooklijn_target); //anti-pendel target
    static float prev_stooklijn_target = id(stooklijn_target); //hold previous value of stooklijn target, to check for change
    float delta = id(stooklijn_target)-tracking_value; //Current Error value
    const float pendel_delta = temp_new_target-tracking_value; //Error value in regard to pendel target
    float derivative_D_5 = 0; //derivative based on past 5 minutes
    float derivative_D_10 = 0; //derivative based on past 10 minutes
    
    run_time += dt;
    if(run_time % alive_timer == 0){
      ESP_LOGD(state_string[state], "**alive** timer: %d oat: %f inlet: %f outlet: %f stooklijn: %f pendel: %f delta: %f pendel_delta: %f ",run_time,id(buiten_temp).state,id(water_temp_retour).state,id(water_temp_aanvoer).state,id(stooklijn_target),temp_new_target,delta,pendel_delta);
    }

    //if delta <= 0 set silent mode unless oat < oat_silent_always_off
    if(delta <= 0 && oat > id(oat_silent_always_off).state && !id(silent_mode).state) {
      ESP_LOGD(state_string[state],"Delta < 0 and silent mode off, switching silent mode on");
      id(silent_mode_switch).turn_on();
    }
    
    //***************************************************************
    //************************ handle events ************************
    //***************************************************************
    //update stooklijn
    if(id(update_stooklijn)||state==INIT||state==START) calculate_stooklijn();
    if(id(stooklijn_target) != prev_stooklijn_target){
      //value changed, recalculate delta;
      ESP_LOGD(state_string[state],"Stooklijn target changed, recalculating delta.");
      delta = id(stooklijn_target)-tracking_value;
    }

    //switch off check
    if(state != INIT && state != IDLE && state != EARLYRUN && state != HALT && state != AFTERRUN && state != DEFROSTING){
      if(check_switch_off(state, run_time, run_start_time)){
        ESP_LOGD(state_string[state],"Detected valid switch off request");
        state = HALT;
      }
    }

    //if internal pump running calculate derivative (if pump is not running, this value does not make sense).
    if(id(pump_running).state && state != SWW && state != DEFROSTING){
      //calculate derivative
      calculate_derivative(tracking_value, &derivative, &derivative_D_5, &derivative_D_10);
    } else if(!id(pump_running).state && derivative.size() > 0){
      //if pump not running and derivative has values clear it
      derivative.clear();
      id(derivative_value).publish_state(0);
    }

    //check for a failed run (waiting)
    if(!id(compressor_running).state && id(relay_heat).state && (state == EARLYRUN || state == RUNNING || state == OVERSHOOTING || state != UNDERSHOOTING)){
      ESP_LOGD(state_string[state],"Failed run detected");
      state = WAITING;
    }

    //check for SWW run
    if(id(sww_heating).state && state != SWW){
      ESP_LOGD(state_string[state],"Detected SWW run");
      state = SWW;
    }
    
    //check for defrosting
    if(id(defrosting).state && state != DEFROSTING){
      ESP_LOGD(state_string[state],"Detected defrosting");
      state = DEFROSTING;
    }
    //***************************************************************
    //***************************************************************

    switch (state) {
      case INIT: {
        //early start. Be patient until everything is set up
        if(run_time > 60 && !isnan(id(buiten_temp).state) && !isnan(id(water_temp_aanvoer).state) && !isnan(id(water_temp_retour).state) && !isnan(tracking_value)){
          id(integral_value).publish_state(0);
          id(derivative_value).publish_state(0);
          if(id(thermostat_signal).state) {
            state = START;
          } else {
            id(relay_heat).turn_off();
            id(relay_pump).turn_off();
            state = IDLE;
          }
        }
        break;
      }
      case IDLE: {
        if(id(thermostat_signal).state){
          state = START;
        } else {
          if(id(relay_heat).state) id(relay_heat).turn_off();
          if(id(relay_pump).state) id(relay_pump).turn_off();
        }
        break;
      }
      case START: {
        //wait for thermostat_on delay
        if((run_time - state_change_time) < (id(thermostat_on_delay).state*60)) break;
        //after delay:
        if(!id(thermostat_signal).state){
          //thermostat switcheck off during on delay timer
          state = IDLE;
          break;
        }
        //switch on external pump
        id(relay_pump).turn_on();
        //clear integral
        integral.clear();
        id(integral_value).publish_state(0);
        temp_new_target = min((id(stooklijn_target)-2),(tracking_value-2)); //minimum of tracking value-2 to ensure compressor start
        if(id(silent_mode).state && (oat < id(oat_silent_always_off).state || (oat <= 3 && delta >= 3))) id(silent_mode_switch).turn_off();
        else id(silent_mode_switch).turn_on();
        ESP_LOGD(state_string[state], "Run start initial target set; stooklijn_target: %f pendel_target: %f inlet: %f outlet: %f",id(stooklijn_target),temp_new_target,id(water_temp_aanvoer).state,id(water_temp_retour).state);
        //switch on heatpump external thermostat contact
        id(relay_heat).turn_on();
        run_start_time = run_time;
        state = STARTING;
        break;
      }
      case STARTING: {
        if(id(compressor_running).state){
          //we have ignition
          state = EARLYRUN;
          compressor_time = run_time;
        }
        break;
      }
      case EARLYRUN: {
        //no switch-off check as min_run_time has definately not passed
        //update target if stooklijn value changed. No modulation as this is useless during early run
        if(id(stooklijn_target) != prev_stooklijn_target) temp_new_target = id(stooklijn_target)-2;
        //protect against strange target swings or instant overshoot during startup
        if(temp_new_target-tracking_value < -3){
          state = OVERSHOOTING;
          break;
        }
        //check if early run finished
        if((run_time - state_change_time) > (15*60)) state = RUNNING;
        break;
      }
      case RUNNING: {
        //check if value changed
        if(prev_stooklijn_target != id(stooklijn_target)) {
          //if new target is higher than tracking value, use undershooting algoritm to raise target
          //if new target is lower than tracking value, use overshooting to lower target
          if(id(stooklijn_target) > tracking_value) {
            ESP_LOGD(state_string[state],"Target changed: new state will be overshooting");
            state = UNDERSHOOTING;
            break;
          } else if(id(stooklijn_target) < tracking_value){
            ESP_LOGD(state_string[state],"Target changed: new state will be undershooting");
            state = OVERSHOOTING;
            break;
          } 
          ESP_LOGD(state_string[state],"Target changed: Setting new target: %f",temp_new_target);
        }
        //check if overshooting, or overshoot predicted
        //overshooting is raising the pendel_target temporarily, allowing to 'overshoot' the stooklijn target
        //the aim is  to prevent the run from being stopped.
        //when an overshoot is predicted the system first tries to avoid by undershooting
        //undershooting is setting the pendel_target below the stooklijn target to force modulation
        //if undershooting does not prevent overshooting, the overschooting logic kicks in and tries to gently lower the
        //temperature back to the target
            
        //predicted temperature to reach in 20 minutes
        float pred_tracking_value_5 = tracking_value + (derivative_D_5*20);
        float pred_tracking_value_10 = tracking_value + (derivative_D_10*20);
        //predicted temperature to reach in 5 minutes
        float pred_5_tracking_value_5 = tracking_value + (derivative_D_5*5);
        //check if intervention needed
        // checkk if already hysteresis degrees above target
        // or if overshoot of more then 2 degrees is predicted in the next 20 minutes
        if(tracking_value >= id(stooklijn_target)-hysteresis || (pred_tracking_value_5 > id(stooklijn_target)+2 && pred_tracking_value_10 > id(stooklijn_target)+2)){
          //start undershooting to force HP into modulation
          temp_new_target = floor(tracking_value)-hysteresis + 1;
          if(temp_new_target > id(stooklijn_target)){
            //intervention too late, straight to overshooting
            ESP_LOGD(state_string[state],"New state will be overshooting, new target: %f pred_D_5: %f pred_D_10: %f",temp_new_target,pred_tracking_value_5,pred_tracking_value_10);
            state = OVERSHOOTING;
            break;
          } else if(temp_new_target == id(stooklijn_target)){
            //do nothing for now
            break;
          } else if(temp_new_target < id(stooklijn_target)) {
            //undershooting
            ESP_LOGD(state_string[state],"New state will be undershooting, new target: %f pred_D_5: %f pred_D_10: %f",temp_new_target,pred_tracking_value_5,pred_tracking_value_10);
            state = UNDERSHOOTING;
          } //else status quo
        }       
        break;
      }
      case OVERSHOOTING: {
        //overshooting logic
        //logic to temporarily overshoot and then return back to target
        if((pendel_delta + hysteresis) <= 0 ){
          //run is about to be killed, raise target if there is still room
          temp_new_target = temp_new_target + 1;
          if(temp_new_target > id(stooklijn_target) + max_overshoot) temp_new_target = id(stooklijn_target) + max_overshoot;
          ESP_LOGD(state_string[state], "Overshooting: raised target (if there was room)");
        } else if(temp_new_target > id(stooklijn_target)){
          //check if target can be lowered without killing the run
          if(pendel_delta + (hysteresis-1) >= 0 ){
            temp_new_target = max(id(stooklijn_target),temp_new_target - 1);
          }
          ESP_LOGD(state_string[state], "Overshooting: checked if target could be lowered");
        } else if(temp_new_target <= id(stooklijn_target)){
          //No need to lower target further
          temp_new_target = max(temp_new_target,id(stooklijn_target));
          if(delta < 2){
            ESP_LOGD(state_string[state], "Overshooting: all normal next state will be running");
            state = RUNNING;
            break;
          } else {
            ESP_LOGD(state_string[state], "Overshooting: target=stooklijn_target waiting for delta to come down within rage");
          }
        }        
        break;
      }
      case UNDERSHOOTING: {
        //undershooting, logic to force modulation and then raise the target back to stooklijn_target
        if(pendel_delta <= 0-(hysteresis-1)){
          //increase target
          temp_new_target = temp_new_target + 1;
          //reset integral
          integral.clear();
          id(integral_value).publish_state(0);
          ESP_LOGD(state_string[state],"Undershooting: pendel_delta (%f) <= 0-(hysteresis-1) increased target.",pendel_delta);
        } else if(pendel_delta <= 0){
          //temperature is more than pendel_target, but lower than pendel_target+(hysteresis-1)
          //this is ok as a transient condition, but stalling must be prevented
          //push current error into integral
          float integral_factor = 0.035; //1 degree 15 minutes
          if ((int)id(compressor_rpm).state < 20 || delta <= 0) integral_factor = 0.125; //1 degree 4 minutes
          else if ((int)id(compressor_rpm).state < 30) integral_factor = 0.05; //1 degree 10 minutes
          else if ((int)id(compressor_rpm).state > 50) integral_factor = 0.025; //1 degree 20 minutes
          float i_number = integral_factor;
          integral.push_back(i_number);
          //limit size to 40 elements (20 minutes)
          if(integral.size() > 40) integral.erase(integral.begin());
          //check current integral error
          float integral_I = 0;
          for(auto it : integral){
            integral_I = integral_I + it;
          }
          ESP_LOGD(state_string[state],"Undershooting: pendel_delta <= 0 loaded integral. integral: %f",integral_I);
          //if integral error is more than 1 
          if(integral_I >= 1.0){
            temp_new_target = temp_new_target + 1;
            //clear integral
            integral.clear();
            integral_I = 0;
            ESP_LOGD(state_string[state],"Undershooting: integral >= 1 increased target.");
          } else if (integral_I < -1) {
            integral.clear();
            integral.push_back(-1);
            if(i_number > 0) integral.push_back(i_number);
            integral_I = -1;
          }
          id(integral_value).publish_state(integral_I);
        } else {
          //Waiting for delta te become within range
          ESP_LOGD(state_string[state], "Undershooting: waiting for temperature to reach next target.");
        }
        if(temp_new_target >= id(stooklijn_target)){
          //Run under control?
          float pred_5_tracking_value_5 = tracking_value + (derivative_D_5*5);
          if(pred_5_tracking_value_5 > id(stooklijn_target)+hysteresis-1 || tracking_value > id(stooklijn_target)+hysteresis-1){
            //doest look under control, revert to overshooting
            ESP_LOGD(state_string[state], "Run not under control, next state overhooting.");
            state = OVERSHOOTING;
          } else {
            //hand back to normal control logic
            ESP_LOGD(state_string[state], "Run under control, next state running.");
            state = RUNNING;
          }
          integral.clear();
          id(integral_value).publish_state(0);          
        }        
        break;
      }
      case WAITING: {
        //check if value changed
        if(prev_stooklijn_target != id(stooklijn_target)) {
          temp_new_target = id(stooklijn_target);
          ESP_LOGD(state_string[state],"Target changed: Setting new target: %f",temp_new_target);
        }
        //wait for 5 minutes to see if compressor restarts
        if(id(compressor_running).state){
          state = RUNNING;
          break;
        }
        if((run_time - state_change_time) > (5*60)) {
          //force restart (start will set target @ tracking value-2)
          state = START;
        }
        break;
      }
      case SWW:
        if(oat <= id(oat_silent_always_off).state && !id(silent_mode).state) id(silent_mode_switch).turn_off();
        else id(silent_mode_switch).turn_on();
        if(!id(sww_heating).state){
          //sww run stopped
          if(!id(thermostat_signal).state){
            state = IDLE;
            break;
           } else {
            if(id(compressor_running).state){
              state = RUNNING;
            } else {
              state = WAITING;
            }
          }
        }
        break;
      case DEFROSTING: {
        if(!id(defrosting).state){
          //defrosting stopped
          //5 minute delay
          if((run_time - state_change_time) < (5*60)) break;
          if(!id(thermostat_signal).state){
            state = IDLE;
            break;
          } else {
            //after delay time, check current target and decide on silent mode
            float t_delta = id(stooklijn_target) - id(water_temp_aanvoer).state;
            if(round(id(buiten_temp).state) <= 3 && t_delta >= 3 && id(silent_mode).state) id(silent_mode_switch).turn_off();
            else if(!id(silent_mode).state && round(id(buiten_temp).state) > id(oat_silent_always_off).state) id(silent_mode_switch).turn_on();
            if(id(compressor_running).state){
              state = RUNNING;
            } else {
              state = WAITING;
            }
          }
        }
        break;
      }
      case HALT: {
        //wait for thermostat_off delat
        if((run_time - state_change_time) < (id(thermostat_off_delay).state*60)) break;
        //after delay:
        if(id(thermostat_signal).state){
          //thermostat reset, so continue operation
          state = RUNNING;
          break;
        }
        //thermostat not switched on again, so halt session
        id(relay_heat).turn_off();
        state = AFTERRUN;
        break;
      }
      case AFTERRUN: {
        if(run_time - state_change_time > (id(minimum_run_time).state*60)){
          id(relay_pump).turn_off();
          state = IDLE;
        }
        break;
      }
    }
        
    //Calculate new (anti pendel) target
    //Basic algorithm
    //System initializes at the start of a run (when working mode changes 2)
    //Then sets initial target to 'real' target minus 4. With a minimum of tracking_value + 2 to ensure compressor start.
    //Maximum value is 'real' target. 
    //When the compressor turns on the logic starts running, monitorring the overshoot of the temporary target
    //When the overshoot approaches hysteresis - 1 the temporary target is increased by 1 until temporary target == real target
    //When the temporary target equals the 'real' target temperature, or the tracking value equals the 'real' target the logic stops so the HP can take over again an run its own logic
    //System resets at heating mode stop (system working mode 0) for example when the room thermostat stops the heating or compressor restart with delta > 1.8
    //While the tracking value is above the temporary_target, but below the 'real' target an integral is loaded
    //Every time the integral hits the limit temporary_target is raised by 1.
    
    if((float)temp_new_target != (float)id(doel_temp).state){
      //Update target through modbus
      set_target_temp(temp_new_target);
      id(doel_temp).publish_state(temp_new_target*10);
    }
    
    if(state != prev_state){
      id(controller_state).publish_state(state_string[state]);
      state_change_time = run_time;
      prev_state = state;
    }
    if(prev_stooklijn_target != id(stooklijn_target)) prev_stooklijn_target = id(stooklijn_target);
    return;