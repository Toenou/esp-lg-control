substitutions:
  device_name: esp-wp-control

esphome:
  name: "${device_name}"
  on_boot:
    priority: 200
    then:
      lambda: !lambda |-
          //Set initial states
          id(force_update_stooklijn) = true;
          id(run_start) = false;
          id(minimum_run_time_passed) = false;
          id(switch_off_requested) = false;
          id(relay1).turn_off();
          if (id(thermostat_signal).state) {
            id(relay2).turn_on();
            id(relay1).turn_on();
          } else {
            id(relay2).turn_off();
          }
          
packages:
  config_values: !include config/config.yaml

# Enable logging. Disable modbus controller debug messages
logger:
  logs:
    modbus_controller.sensor: WARN
    modbus_controller.output: WARN
    esp32.preferences: WARN
    sensor: WARN

globals:
  - id: stooklijn_target
    type: float
    restore_value: no
    initial_value: '26'
  - id: force_update_stooklijn
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: working_mode
    type: int
    restore_value: no
    initial_value: '0'
  - id: var_pendel_watertemp_target
    type: float
    restore_value: no
    initial_value: '26'
  - id: run_start
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: minimum_run_time_passed
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: switch_off_requested
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: modulation_started
    type: bool
    restore_value: no
    initial_value: 'false'
number:
  - platform: template
    name: "Stooklijn offset"
    id: wp_stooklijn_offset
    min_value: -5
    max_value: 5
    initial_value: 0
    step: 1
    restore_value: yes
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_min_oat
    name: "Stooklijn Minimum Buitentemperatuur"
    min_value: -25
    max_value: 0
    step: 1
    restore_value: yes
    initial_value: -15
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_max_wtemp
    name: "Stooklijn Maximum Watertemperatuur"
    min_value: 20
    max_value: 60
    step: 1
    restore_value: yes
    initial_value: 51
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_min_wtemp
    name: "Stooklijn Minimum Watertemperatuur"
    min_value: 20
    max_value: 35
    step: 1
    restore_value: yes
    initial_value: 26
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_start_temp
    name: "Stooklijn Start Buitentemperatuur"
    min_value: 0
    max_value: 20
    step: 1
    restore_value: yes
    initial_value: 10
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: minimum_run_time
    name: "Minimale run tijd"
    min_value: 0
    max_value: 30
    step: 1
    restore_value: yes
    initial_value: 30
    unit_of_measurement: "min"
    optimistic: true
  - platform: template
    id: thermostat_off_delay
    name: "thermostat off delay"
    min_value: 0
    max_value: 10
    step: 1
    restore_value: yes
    initial_value: 1
    unit_of_measurement: "min"
    optimistic: true
  - platform: template
    id: thermostat_on_delay
    name: "thermostat on delay"
    min_value: 0
    max_value: 10
    step: 1
    restore_value: yes
    initial_value: 0
    unit_of_measurement: "min"
    optimistic: true
  - platform: template
    id: external_pump_runover
    name: "External pump overrun"
    min_value: 0
    max_value: 60
    step: 1
    restore_value: yes
    initial_value: 20
    unit_of_measurement: "min"
    optimistic: true
switch:
  - platform: gpio
    name: "WP External Pump"
    pin: 18
    id: relay1
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: gpio
    name: "WP Heat"
    pin: 19
    id: relay2
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      then:
        - lambda: |-
            //Update working mode
            id(working_mode) = 0;
            id(minimum_run_time_script).stop();
            id(anti_pendel_off).stop();
            id(modulation_start_script).stop();
            id(external_pump_script).execute();
    on_turn_on:
      then:
        - lambda: |-
            //Turn on external pump
            id(relay1).turn_on();
            //stop the script that stops the pump after x minutes
            id(external_pump_script).stop();
            //Update working mode
            id(working_mode) = 2;
            id(run_start) = true;
            id(minimum_run_time_passed) = false;
            id(switch_off_requested) = false;
            id(modulation_started) = false;
            id(minimum_run_time_script).execute();
            id(modulation_start_script).execute();
  - platform: output
    name: "Silent Mode"
    output: 'modbus_set_silent_mode'

# External thermostat anti pendel script. Some thermostats (Eneco Toon is really bad) sometimes temporarily switches the output off, while heat is still needed
# This script delays switching the heating of for x minutes. If heating switches back on within this timeframe the script stops
# An other 'nice' feature of Toon is that it sometimes switches on the heating for only 1 or 2 minutes and then off again
script:
  - id: anti_pendel_off
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("thermostat-delay", "anti_pendel_off called.");
          //If heating active and compressor is not running, switch off instantly
          if(!id(compressor_running).state && id(working_mode) == 2){
            ESP_LOGD("thermostat-delay", "Compressor not running. Instant off.");
            id(relay2).turn_off();
          }else {
            ESP_LOGD("thermostat-delay", "anti_pendel_off called. starting delay timer. minimum_run_time_passed: %d",id(minimum_run_time_passed));
          }
      - delay: !lambda "return id(thermostat_off_delay).state*60*1000;"
      - lambda: |-
          //If minimum run time passed switch off. Otherwise flag switch off requested (will be picked up by minimum_run_time_script)
          ESP_LOGD("thermostat-delay", "anti_pendel_off delay passed. minimum_run_time_passed: %d",id(minimum_run_time_passed));
          if(id(minimum_run_time_passed)||(!id(compressor_running).state && id(working_mode) == 2)){
            id(relay2).turn_off();
          } else {
            id(switch_off_requested) = true;
          }
  - id: anti_pendel_on
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("thermostat-delay", "anti_pendel_on called starting delay timer.");
      - delay: !lambda "return id(thermostat_on_delay).state*60*1000;"
      - lambda: |-
          ESP_LOGD("thermostat-delay", "anti_pendel_on delay passed starting HP.");
          //Turn on HP
          id(relay2).turn_on();
  - id: minimum_run_time_script
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("thermostat-delay", "minimum_run_time_script called starting delay timer.");
      - delay: !lambda "return id(minimum_run_time).state*60*1000;"
      - lambda: |-
          //Set minum run time passed to true, so that HP can switch off when thermostat switches off (after delay)
          ESP_LOGD("thermostat-delay", "minimum_run_time_script delay passed. switch_off_requested: %d",id(switch_off_requested));
          id(minimum_run_time_passed) = true;
          //Check if switch off was already requested
          if(id(switch_off_requested)){
            //Switch off
            id(relay2).turn_off();
            id(anti_pendel_off).stop();
          }
  - id: modulation_start_script
    mode: restart
    then:
      - delay: !lambda "return id(external_pump_runover).state*60*1000;"
      - lambda: |-
          //Set modulation_started to true
          id(modulation_started) = true;
          ESP_LOGD("anti-pendel", "Modulation_started = true.");
  - id: external_pump_script
    mode: restart
    then:
      - delay: !lambda "return 15*60*1000;"
      - lambda: |-
          //switch off pump after delay time
          id(relay1).turn_off();
                  
modbus:
  id: modbus_lg
  uart_id: uart_modbus
  send_wait_time: 200ms
  
uart:
  tx_pin: GPIO26
  rx_pin: GPIO25
  baud_rate: 9600
  id: uart_modbus
  parity: none
  data_bits: 8
  stop_bits: 1

modbus_controller:
  - id: lg
    address: 0x1 # the Modbus device addr
    modbus_id: modbus_lg
    update_interval: 20s #this is our main 'clock' all dependel logic follows this pace
    setup_priority: -10

output:
  - platform: modbus_controller
    modbus_controller_id: lg
    id: water_temp_target_output
    register_type: holding
    address: 2
    value_type: U_WORD
    multiply: 1000
  - platform: modbus_controller
    modbus_controller_id: lg
    id: modbus_set_silent_mode
    register_type: coil
    address: 2
 
binary_sensor:
  - platform: gpio # Thermostat input signal is connected to this input pin
    pin:
      number: GPIO27
      mode:
        input: true
        pullup: false
    name: "WP Nest Signal"
    id: thermostat_signal
    filters:
      - delayed_on: 500ms # Debounce
    on_press:
      # Reset switch_off_requested
      - globals.set:
          id: switch_off_requested
          value: 'false'
      - script.execute: anti_pendel_on # Anti pendel script, to delay switch on for x minutes
      - script.stop: anti_pendel_off # Anti pendel script, to delay switch off for x minutes
    on_release:
      - script.execute: anti_pendel_off
      - script.stop: anti_pendel_on
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Pump Running"
    id: pump_running
    register_type: discrete_input
    skip_updates: 3
    address: 1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Compressor Running"
    id: compressor_running
    register_type: discrete_input
    skip_updates: 3
    address: 3
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Defrosting"
    id: defrosting
    register_type: discrete_input
    skip_updates: 6
    address: 4
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Silent Mode"
    id: silent_mode
    register_type: discrete_input
    skip_updates: 6
    address: 7

    
sensor:
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Bedrijfsmodus"
    id: bedrijfsmodus
    register_type: read
    address: 1
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water retour"
    id: water_temp_retour
    register_type: read
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water aanvoer"
    id: water_temp_aanvoer
    register_type: read
    address: 3
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
    on_value:
      then:
        - lambda: |-
            //Main program logic this loop runs every 'clock' cycle when modbus data is received for this sensor
            static int alive_timer = 0;
            
            //Set controller control mode to 'outlet' and set hysteresis to the setting you have on the controller (recommend 4)
            const static int hysteresis = 3;
            //The algoritm will allow an overshoot (over the hysteresis) for the first 15 minutes to not kill an ongoing run that is about to start modulating
            //Rather settle at a slightly higher temperature than start 'pendeling'
            const static int max_overshoot = 2; //So maximum overshoot of hysteresis + max_overshoot
            static bool overshooting = false;
            //Set to value that anti-pendel script will track (outlet/inlet) (recommend outlet)
            const float tracking_value = id(water_temp_retour).state;

            if(alive_timer == 0){
              //Post an 'alive' debug message in the logs every 300 seconds
              alive_timer = 16; //300 seconds
              ESP_LOGD("anti-pendel", "**alive** oat: %f inlet: %f outlet: %f ",id(buiten_temp).state,id(water_temp_retour).state,x);
            }
            alive_timer--;
            //Wait for valid oat reading
            if(isnan(id(buiten_temp).state)) return;
            //Do not run script if working mode = 0
            if(id(working_mode) == 0) return;
            
            //Hold previous script run ota value to check if it changed since last run
            static float prev_oat = 0;
            //Pump pre run time
            static int pre_run_time = 0;
            //System logic (to switch off agressive target setting after target is reached)
            static bool target_reached = false;
            
            //Calculate stooklijn target
            float oat = round(id(buiten_temp).state);
            //If no oat change, no update needed, unless forced or first run
            if(prev_oat != oat || id(force_update_stooklijn) || id(run_start)){
              prev_oat = oat;
              //reset force boolean
              id(force_update_stooklijn) = false;
              //Heating
              //Formula is wTemp = -Z x (OAT-stooklijn_min_wtemp) + stooklijn_start_temp
              //Formula to calculate -Z = ((stooklijn_max_wtemp-stooklijn_min_wtemp)) / (stooklijn_min_oat - stooklijn_start_temp))
              const float Z = ((float)id(stooklijn_max_wtemp).state-(float)id(stooklijn_min_wtemp).state)/( (float)id(stooklijn_min_oat).state - (float)id(stooklijn_start_temp).state);
              ESP_LOGD("stooklijn", "Stooklijn, working mode is heating, with oat: %f, Z: %f",oat, Z);
              if(oat < id(stooklijn_min_oat).state) {
                //If oat below minimum oat, clamp to minimum value
                oat = id(stooklijn_min_oat).state;
              } else if (oat > id(stooklijn_start_temp).state) {
                //If oat above max value, clamp to maximum value
                oat = id(stooklijn_start_temp).state;
              }
              id(stooklijn_target) = (int)round((Z * (oat-id(stooklijn_min_wtemp).state))+id(stooklijn_start_temp).state);
              //Add stooklijn offset
              id(stooklijn_target) = id(stooklijn_target) + id(wp_stooklijn_offset).state;
              //Make sure target is not above max water or below minimum temp
              if(id(stooklijn_target) > id(stooklijn_max_wtemp).state) id(stooklijn_target) = id(stooklijn_max_wtemp).state;
              if(id(stooklijn_target) < id(stooklijn_min_wtemp).state) id(stooklijn_target) = id(stooklijn_min_wtemp).state;
              
              ESP_LOGD("stooklijn", "New stooklijn target value (after correction): %f", id(stooklijn_target));
              //Publish new stooklijn value to watertemp value sensor
              id(watertemp_target).publish_state(id(stooklijn_target));
            }
            //New anti-pendel target
            float temp_new_target = id(stooklijn_target);
            //Calculate new (anti pendel) target
            //Very basic algorithm
            //System initializes at the start of a run (when working mode changes to 1 or 2)
            //Then sets initial target to 'real' target, to allow HP to start up (if water temp below HP hysteresis setting)
            //When the compressor turns on the logic starts running, setting a new target at 2 degrees below actual return temp when actual within hysteresis degrees of target
            //When the new target equals the target temperature the logic stops, fixating the target so the HP can take over again an run its own logic
            //System resets at heating mode stop (system working mode 0) for example when the room thermostat stops the heating
            if(id(run_start)){
              //Initialize values. run_start is set to true by the switches that control heating mode
              pre_run_time = 5; // equals 100 seconds. Based on 20s 'clock'
              //Activate system
              target_reached = false;
              temp_new_target = id(stooklijn_target);
              overshooting = false;
              ESP_LOGD("anti-pendel", "Run start initial values set; target: %f inlet: %f outlet: %f",id(stooklijn_target),x,id(water_temp_retour).state);
              id(run_start) = 0;
            }
            
            //System will only run when delta return vs target is < 3 to prevent stabilising on too low temperature
            const float delta = id(stooklijn_target)-tracking_value;
            //Run when compressor is running and target not reached and actual return temp within 3 degrees of target
            if(id(compressor_running).state && !target_reached && delta < 3){
              //Agressive target setting
              temp_new_target = ((tracking_value-3)*10)/10;
              if(temp_new_target > id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              ESP_LOGD("anti-pendel", "RETURN_TEMP: %f OUTLET_TEMP: %f TARGET: %f PENDEL_TARGET: %f TRACKING_VALUE: %f OVERSHOOTING: %d",id(water_temp_retour).state,x,id(stooklijn_target),temp_new_target,tracking_value,overshooting);
            } else if(id(compressor_running).state && !target_reached) {
              //Waiting for delta te become within range, less agressive target setting
              temp_new_target = round((tracking_value-1)*10)/10;
              if(temp_new_target > id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              ESP_LOGD("anti-pendel", "Waiting for delta RETURN_TEMP: %f OUTLET_TEMP: %f DELTA: %f PENDEL_TARGET: %f",id(water_temp_retour).state,x,delta,temp_new_target);
            } else if(!target_reached && pre_run_time > 0) {
              //Make sure target remains at stooklijn target to ensure compressor start (if ok according to WP own logic)
              temp_new_target = id(stooklijn_target);
              //Update pre_run_time counter
              ESP_LOGD("anti-pendel", "Waiting for pre_run_time: %i",pre_run_time);
              pre_run_time--;
            }
            
            //Make sure changes in stooklijn are processed when target reached
            if(target_reached){
              //Do not set a lower target if it kills the run
              if(!(tracking_value > id(stooklijn_target) + hysteresis)) temp_new_target = id(stooklijn_target);
              temp_new_target = id(stooklijn_target);
            }
            if(delta < 0.3 && id(compressor_running).state && !target_reached){
              //Deactive agressive target setting until next run
              temp_new_target = id(stooklijn_target);
              target_reached = true;
              ESP_LOGD("anti-pendel", "Target reached, maintaining target: %f pendel_target: %f",id(stooklijn_target),id(pendel_watertemp_target).state);
            }
            //Allow extra hysteresis during first 15 minutes of heating run
            //Once overshooting = true the extra overshoot is allowed for the remainder of the run
            if((target_reached && !id(modulation_started) && id(working_mode) == 2)||overshooting){
              if(tracking_value > temp_new_target + hysteresis){
                if(tracking_value < (temp_new_target + hysteresis + max_overshoot)){
                  //Overshoot as needed (as it is below max overshoot)
                  temp_new_target = (tracking_value - hysteresis + 0.5);
                } else {
                  //Settle on max overshoot
                  temp_new_target = temp_new_target + max_overshoot;
                }
                overshooting = true;
                ESP_LOGD("anti-pendel", "Overshooting: target: %f pendel_target: %f tracking_value: %f",id(stooklijn_target),temp_new_target,tracking_value);
              }
            } 
            if(temp_new_target != id(var_pendel_watertemp_target) || id(var_pendel_watertemp_target) != id(doel_temp).state){
              //Set new target
              id(var_pendel_watertemp_target) = temp_new_target;
              //Update sensor
              id(pendel_watertemp_target).publish_state(id(var_pendel_watertemp_target));
              //Update target through modbus (set level needs value between 0-1, so divide by 100)
              id(water_temp_target_output).set_level(id(var_pendel_watertemp_target)*0.01);
              //ESP_LOGD("anti-pendel", "New pendel_watertemp_target set: %f outlet: %f",id(pendel_watertemp_target).state,x);
            }
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Garagetemperatuur"
    id: binnen_temp
    register_type: read
    address: 7
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Flow Rate"
    id: current_flow_rate
    register_type: read
    address: 8
    unit_of_measurement: "L/m"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Buitentemperatuur"
    id: buiten_temp
    register_type: read
    address: 12
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Compressor RPM"
    id: compressor_rpm
    register_type: read
    address: 24
    unit_of_measurement: "RPM"
    value_type: U_WORD
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Doeltemperatuur"
    id: doel_temp
    register_type: holding
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: template
    name: "Stooklijn Watertemp Target"
    id: watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return id(stooklijn_target);
  - platform: template
    name: "Anti-pendel Watertemp Target"
    id: pendel_watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return round(id(var_pendel_watertemp_target)*10)/10;
  - platform: wifi_signal
    name: "${device_name} WiFi Signal"
    update_interval: 120s
    accuracy_decimals: 0
  - platform: uptime
    name: "${device_name} Uptime"
    unit_of_measurement: days
    update_interval: 3600s
    accuracy_decimals: 1
    filters:
      - multiply: 0.000011574
# Sensors for ESP version and WIFI information
text_sensor:
  - platform: version
    name: "${device_name} ESPHome Version"
  - platform: wifi_info
    ip_address:
      name: "${device_name} ip"
    ssid:
      name: "${device_name} ssid"