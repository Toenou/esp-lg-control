substitutions:
  device_name: esp-wp-control

esphome:
  name: "${device_name}"
  on_boot:
    priority: 200
    then:
      lambda: !lambda |-
          //set initial states
          id(force_update_stooklijn) = true;
          id(run_start) = false;
          id(minimum_run_time_passed) = false;
          id(switch_off_requested) = false;
          id(relay1).turn_off();
          if (id(toon_signal).state) {
            id(relay2).turn_on();
          } else {
            id(relay2).turn_off();
          }
          
packages:
  config_values: !include config/config.yaml

# Enable logging. Disable modbus controller debug messages
logger:
  logs:
    modbus_controller.sensor: WARN
    modbus_controller.output: WARN
    esp32.preferences: WARN
    sensor: WARN

globals:
  - id: stooklijn_target
    type: float
    restore_value: no
    initial_value: '24'
  - id: force_update_stooklijn
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: working_mode
    type: int
    restore_value: no
    initial_value: '0'
  - id: var_pendel_watertemp_target
    type: float
    restore_value: no
    initial_value: '24'
  - id: run_start
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: minimum_run_time_passed
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: switch_off_requested
    type: bool
    restore_value: no
    initial_value: 'false'
number:
  - platform: template
    name: "Stooklijn offset"
    id: wp_stooklijn_offset
    min_value: -5
    max_value: 5
    initial_value: 0
    step: 1
    restore_value: yes
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_min_oat
    name: "Stooklijn Minimum Buitentemperatuur"
    min_value: -25
    max_value: 0
    step: 1
    restore_value: yes
    initial_value: -20
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_max_wtemp
    name: "Stooklijn Maximum Watertemperatuur"
    min_value: 30
    max_value: 60
    step: 1
    restore_value: yes
    initial_value: 40
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_min_wtemp
    name: "Verwarming Minimum Watertemperatuur"
    min_value: 20
    max_value: 35
    step: 1
    restore_value: yes
    initial_value: 24
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: cooling_target_wtemp
    name: "Koelmodus Watertemperatuur"
    min_value: 16
    max_value: 20
    step: 1
    restore_value: yes
    initial_value: 18
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: minimum_run_time
    name: "Minimale run tijd"
    min_value: 0
    max_value: 30
    step: 1
    restore_value: yes
    initial_value: 15
    unit_of_measurement: "min"
    optimistic: true
  - platform: template
    id: toon_off_delay
    name: "Toon off delay"
    min_value: 0
    max_value: 10
    step: 1
    restore_value: yes
    initial_value: 3
    unit_of_measurement: "min"
    optimistic: true
  - platform: template
    id: toon_on_delay
    name: "Toon on delay"
    min_value: 0
    max_value: 10
    step: 1
    restore_value: yes
    initial_value: 3
    unit_of_measurement: "min"
    optimistic: true

switch:
  - platform: gpio
    name: "WP Cool"
    pin: 18
    id: relay1
    interlock: &interlock_group [relay1, relay2]
    interlock_wait_time: 2000ms
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 0;
    on_turn_on:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 1;
            id(run_start) = true;
            // cooling mode is not controlled by Toon, so no minimum run time applicable
            id(minimum_run_time_passed) = true;
            id(switch_off_requested) = false;            
  - platform: gpio
    name: "WP Heat"
    pin: 19
    id: relay2
    interlock: *interlock_group
    interlock_wait_time: 20s
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 0;
    on_turn_on:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 2;
            id(run_start) = true;
            id(minimum_run_time_passed) = false;
            id(switch_off_requested) = false;
            id(minimum_run_time_script).execute();
  - platform: output
    name: "Silent Mode"
    output: 'modbus_set_silent_mode'

# Eneco Toon anti pendel script. Toon sometimes temporarily switches the output off, while heat is still needed
# This script delays switching the heating of for x minutes. If heating switches back on within this timeframe the script stops
# An other 'nice' feature of Toon is that it sometimes switches on the heating for only 1 or 2 minutes and then off again
script:
  - id: anti_pendel_off
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("toon-delay", "anti_pendel_off called starting delay timer. minimum_run_time_passed: %d",id(minimum_run_time_passed));
      - delay: !lambda "return id(toon_off_delay).state*60*1000;"
      - lambda: |-
          //if minimum run time passed switch off. Otherwise flag switch off requested (will be picked up by minimum_run_time_script)
          ESP_LOGD("toon-delay", "anti_pendel_off delay passed. minimum_run_time_passed: %d",id(minimum_run_time_passed));
          if(id(minimum_run_time_passed)){
            id(relay2).turn_off();
          } else {
            id(switch_off_requested) = true;
          }
  - id: anti_pendel_on
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("toon-delay", "anti_pendel_on called starting delay timer.");
      - delay: !lambda "return id(toon_on_delay).state*60*1000;"
      - lambda: |-
          ESP_LOGD("toon-delay", "anti_pendel_on delay passed starting HP.");
          // turn on HP
          id(relay2).turn_on();
  - id: minimum_run_time_script
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("toon-delay", "minimum_run_time_script called starting delay timer.");
      - delay: !lambda "return id(minimum_run_time).state*60*1000;"
      - lambda: |-
          //set minum run time passed to true, so that HP can switch off when Toon switches off (after delay)
          ESP_LOGD("toon-delay", "minimum_run_time_script delay passed. switch_off_requested: %d",id(switch_off_requested));
          id(minimum_run_time_passed) = true;
          // check if switch off was already requested
          if(id(switch_off_requested)){
            //switch off
            id(relay2).turn_off();
            id(anti_pendel_off).stop();
          }
          
modbus:
  id: modbus_lg
  uart_id: uart_modbus
  send_wait_time: 200ms
  
uart:
  tx_pin: GPIO26
  rx_pin: GPIO25
  baud_rate: 9600
  id: uart_modbus
  parity: none
  data_bits: 8
  stop_bits: 1

modbus_controller:
  - id: lg
    address: 0x1 # the Modbus device addr
    modbus_id: modbus_lg
    update_interval: 20s #this is our main 'clock' all dependel logic follows this pace
    setup_priority: -10

output:
  - platform: modbus_controller
    modbus_controller_id: lg
    id: water_temp_target_output
    register_type: holding
    address: 2
    value_type: U_WORD
    multiply: 1000
  - platform: modbus_controller
    modbus_controller_id: lg
    id: modbus_set_silent_mode
    register_type: coil
    address: 2
 
binary_sensor:
  - platform: gpio # Toon input signal is connected to this input pin
    pin:
      number: GPIO27
      mode:
        input: true
        pullup: false
    name: "WP Toon Signal"
    id: toon_signal
    filters:
      - delayed_on: 500ms # Debounce
    on_press:
      # Reset switch_off_requested
      - globals.set:
          id: switch_off_requested
          value: 'false'
      - script.execute: anti_pendel_on # Anti pendel script, to delay switch on for x minutes
      - script.stop: anti_pendel_off # Anti pendel script, to delay switch off for x minutes
    on_release:
      - script.execute: anti_pendel_off
      - script.stop: anti_pendel_on
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Silent Mode"
    id: silent_mode
    register_type: discrete_input
    skip_updates: 3
    address: 7
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Pump Running"
    id: pump_running
    register_type: discrete_input
    skip_updates: 3
    address: 1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Compressor Running"
    id: compressor_running
    register_type: discrete_input
    skip_updates: 3
    address: 3
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Defrosting"
    id: defrosting
    register_type: discrete_input
    skip_updates: 3
    address: 4
    
sensor:
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Buitentemperatuur"
    id: buiten_temp
    register_type: read
    address: 12
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water retour"
    id: water_temp_retour
    register_type: read
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water aanvoer"
    id: water_temp_aanvoer
    register_type: read
    address: 3
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
    on_value:
      then:
        - lambda: |-
            //Main program logic this loop runs every 'clock' cycle when modbus data is received for this sensor
            static int alive_timer = 0;
            const static int hysteresis = 2;
            if(alive_timer == 0){
              // post an 'alive' debug message in the logs every 300 seconds
              alive_timer = 16; //300 seconds
              ESP_LOGD("anti-pendel", "**alive** oat: %f inlet: %f outlet: %f ",id(buiten_temp).state,id(water_temp_retour).state,x);
            }
            alive_timer--;
            //wait for valid oat reading
            if(isnan(id(buiten_temp).state)) return;
            //Do not run script if working mode = 0
            if(id(working_mode) == 0) return;
            
            // hold previous script run ota value to check if it changed since last run
            static float prev_oat = 0;
            //pre run time
            static int pre_run_time = 0;
            //system logic (to switch off after target is reached)
            static bool target_reached = false;
            
            // calculate stooklijn target
            float oat = round(id(buiten_temp).state);
            // if no oat change, no update needed, unless forced or first run
            if(prev_oat != oat || id(force_update_stooklijn) || id(run_start)){
              prev_oat = oat;
              //reset force boolean
              id(force_update_stooklijn) = false;
              if(id(working_mode) == 1){
                //Cooling
                ESP_LOGD("stooklijn", "Stooklijn, working mode is cooling");
                id(stooklijn_target) = id(cooling_target_wtemp).state;
              } else {
                //Heating
                //formula is wTemp = -Z x (OAT-20) + 20
                //formula to calculate -Z = ((wTempMax-20) / (OATMin - 20))
                const float Z = ((float)id(stooklijn_max_wtemp).state-20)/(float)(((float)id(stooklijn_min_oat).state) - 20);
                ESP_LOGD("stooklijn", "Stooklijn, working mode is heating, with oat: %f, Z: %f",oat, Z);
                if(oat < id(stooklijn_min_oat).state) {
                  //if oat below minimum oat, clamp to minimum value
                  oat = id(stooklijn_min_oat).state;
                } else if (oat > 20) {
                  //if oat above max value, clamp to maximum value
                  oat = 20;
                }
                id(stooklijn_target) = (int)round((Z * (oat-20))+20);
                //add stooklijn offset
                id(stooklijn_target) = id(stooklijn_target) + id(wp_stooklijn_offset).state;
                //
                if(id(stooklijn_target) > id(stooklijn_max_wtemp).state) id(stooklijn_target) = id(stooklijn_max_wtemp).state;
                //minimum water temp when in heating mode (in case of radiators)
                if(id(stooklijn_target) < id(stooklijn_min_wtemp).state) id(stooklijn_target) = id(stooklijn_min_wtemp).state;
              }
              ESP_LOGD("stooklijn", "New stooklijn target value (after correction): %f", id(stooklijn_target));
              //publish new stooklijn value to watertemp value sensor
              id(watertemp_target).publish_state(id(stooklijn_target));
            }
            //new anti-pendel target
            float temp_new_target = id(var_pendel_watertemp_target);
            // calculate new (anti pendel) target
            // very basic algorithm
            // After testing it looks like modulation is triggered by return temp and not by supply temp
            // Supply temp will trigger a shut down of the compressor, but does not seem te trigger modulation
            // it initializes at the start of a run (when working mode changes tot 1 or 2)
            // then sets initial target to 'real' target, to allow HP to start up
            // when the compressor turn on the logic start running, setting a new target at 1 degrees below actual return temp when actual within hysteresis-1 degrees of target
            // when the new target equals the new target the logic stops, so the HP can take over again an run its own logic
            // system resets at heating/cooling mode stop (system working mode 0) for example when the room thermostat stops the heating
            if(id(run_start)){
              //initialize values. run_start is set to true by the switches that control heating/cooling mode
              pre_run_time = 5; // equals 100 seconds. Based on 20s 'clock'
              //activate system
              target_reached = false;
              //Set initial target to trigger compressor startup (set level needs value between 0-1, so divide by 100)
              id(var_pendel_watertemp_target) = id(stooklijn_target);
              temp_new_target = id(stooklijn_target);
              id(water_temp_target_output).set_level(id(stooklijn_target)*0.01);
              id(pendel_watertemp_target).publish_state(id(var_pendel_watertemp_target));
              ESP_LOGD("anti-pendel", "Run start initial values set; target: %f outlet: %f",id(stooklijn_target),x);
              id(run_start) = 0;
            }
            //wait for valid water temp return reading
            if(isnan(id(water_temp_retour).state)) return;
            temp_new_target = id(water_temp_retour).state;
            //system will only run when delta return vs target is < hysteresis+2 to prevent triggering a switch off
            const float delta = abs(id(stooklijn_target)-id(water_temp_retour).state);
            //Run when compressor is running and target not reached and actual return temp within hysteresis+2 degrees of target
            if(id(compressor_running).state && !target_reached && delta < (hysteresis+2)){
              if(id(working_mode) == 1) temp_new_target = ceil((temp_new_target+hysteresis)*2)/2;
              else if(id(working_mode) == 2) temp_new_target = floor((temp_new_target-(hysteresis))*2)/2;
              //make sure value is not below target (cooling), or above target (heating) and make sure pendel target is not below hysteresis of output temp
              if(id(working_mode) == 1 && temp_new_target < id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              else if(temp_new_target > id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              ESP_LOGD("anti-pendel", "RETURN_TEMP: %f OUTLET_TEMP: %f TARGET: %f PENDEL_TARGET: %f",id(water_temp_retour).state,x,id(stooklijn_target),temp_new_target);
            } else if(!target_reached && pre_run_time > 0) {
              //update pre_run_time counter
              ESP_LOGD("anti-pendel", "Waiting for pre_run_time: %i",pre_run_time);
              pre_run_time--;
            } else if(!target_reached) {
              //waiting for delta te become within range
              if(id(working_mode) == 1) {
                temp_new_target = ceil((temp_new_target-hysteresis)*2)/2;
                if(temp_new_target < id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              } else if(id(working_mode) == 2){
                temp_new_target = floor((temp_new_target+hysteresis)*2)/2;
                if(temp_new_target > id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              }
              ESP_LOGD("anti-pendel", "Waiting for delta RETURN_TEMP: %f OUTLET_TEMP: %f DELTA: %f PENDEL_TARGET: %f",id(water_temp_retour).state,x,delta,temp_new_target);
            }
            
            //make sure changes in stooklijn are processed when target reached
            if(target_reached){
                temp_new_target = id(stooklijn_target);
            }

            if(temp_new_target != id(var_pendel_watertemp_target)){
              //set new target
              id(var_pendel_watertemp_target) = temp_new_target;
              //update sensor
              id(pendel_watertemp_target).publish_state(id(var_pendel_watertemp_target));
              //update target through modbus (set level needs value between 0-1, so divide by 100)
              id(water_temp_target_output).set_level(id(var_pendel_watertemp_target)*0.01);
              // ESP_LOGD("anti-pendel", "New pendel_watertemp_target set: %f outlet: %f",id(pendel_watertemp_target).state,x);
              if(temp_new_target == id(stooklijn_target)){
                //deactive system logic until next run
                target_reached = true;
                ESP_LOGD("anti-pendel", "Target reached, system inactive target: %f pendel_target: %f",id(stooklijn_target),id(pendel_watertemp_target).state);
              }
            }
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Garagetemperatuur"
    id: binnen_temp
    register_type: read
    address: 7
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Flow Rate"
    id: current_flow_rate
    register_type: read
    address: 8
    unit_of_measurement: "L/m"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Bedrijfsmodus"
    id: bedrijfsmodus
    register_type: read
    address: 1
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Doeltemperatuur"
    id: doel_temp
    register_type: holding
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    skip_updates: 3
    filters:
      - multiply: 0.1
  - platform: template
    name: "Stooklijn Watertemp Target"
    id: watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return id(stooklijn_target);
  - platform: template
    name: "Anti-pendel Watertemp Target"
    id: pendel_watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return round(id(var_pendel_watertemp_target)*10)/10;
  - platform: wifi_signal
    name: "${device_name} WiFi Signal"
    update_interval: 120s
    accuracy_decimals: 0
  - platform: uptime
    name: "${device_name} Uptime"
    unit_of_measurement: days
    update_interval: 3600s
    accuracy_decimals: 1
    filters:
      - multiply: 0.000011574
# Sensors for ESP version and WIFI information
text_sensor:
  - platform: version
    name: "${device_name} ESPHome Version"
  - platform: wifi_info
    ip_address:
      name: "${device_name} ip"
    ssid:
      name: "${device_name} ssid"