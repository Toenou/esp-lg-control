substitutions:
  device_name: esp-wp-control

esphome:
  name: "${device_name}"
  on_boot:
    priority: 200
    then:
      lambda: !lambda |-
          //Set initial states
          id(force_update_stooklijn) = true;
          id(run_start) = false;
          id(minimum_run_time_passed) = false;
          id(switch_off_requested) = false;
          id(relay1).turn_off();
          if (id(toon_signal).state) {
            id(relay2).turn_on();
          } else {
            id(relay2).turn_off();
          }
          
packages:
  config_values: !include config/config.yaml

# Enable logging. Disable modbus controller debug messages
logger:
  logs:
    modbus_controller.sensor: WARN
    modbus_controller.output: WARN
    esp32.preferences: WARN
    sensor: WARN

globals:
  - id: stooklijn_target
    type: float
    restore_value: no
    initial_value: '27'
  - id: force_update_stooklijn
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: working_mode
    type: int
    restore_value: no
    initial_value: '0'
  - id: var_pendel_watertemp_target
    type: float
    restore_value: no
    initial_value: '27'
  - id: run_start
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: minimum_run_time_passed
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: switch_off_requested
    type: bool
    restore_value: no
    initial_value: 'false'
number:
  - platform: template
    name: "Stooklijn offset"
    id: wp_stooklijn_offset
    min_value: -5
    max_value: 5
    initial_value: 0
    step: 1
    restore_value: yes
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_min_oat
    name: "Stooklijn Minimum Buitentemperatuur"
    min_value: -25
    max_value: 0
    step: 1
    restore_value: yes
    initial_value: -15
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_max_wtemp
    name: "Stooklijn Maximum Watertemperatuur"
    min_value: 20
    max_value: 60
    step: 1
    restore_value: yes
    initial_value: 53
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_min_wtemp
    name: "Verwarming Minimum Watertemperatuur"
    min_value: 20
    max_value: 35
    step: 1
    restore_value: yes
    initial_value: 28
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: cooling_target_wtemp
    name: "Koelmodus Watertemperatuur"
    min_value: 16
    max_value: 20
    step: 1
    restore_value: yes
    initial_value: 18
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: minimum_run_time
    name: "Minimale run tijd"
    min_value: 0
    max_value: 30
    step: 1
    restore_value: yes
    initial_value: 30
    unit_of_measurement: "min"
    optimistic: true
  - platform: template
    id: toon_off_delay
    name: "Toon off delay"
    min_value: 0
    max_value: 10
    step: 1
    restore_value: yes
    initial_value: 3
    unit_of_measurement: "min"
    optimistic: true
  - platform: template
    id: toon_on_delay
    name: "Toon on delay"
    min_value: 0
    max_value: 10
    step: 1
    restore_value: yes
    initial_value: 3
    unit_of_measurement: "min"
    optimistic: true

switch:
  - platform: gpio
    name: "WP Cool"
    pin: 18
    id: relay1
    interlock: &interlock_group [relay1, relay2]
    interlock_wait_time: 2000ms
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      then:
        - lambda: |-
            //Update working mode
            id(working_mode) = 0;
    on_turn_on:
      then:
        - lambda: |-
            //Update working mode
            id(working_mode) = 1;
            id(run_start) = true;
            // cooling mode is not controlled by Toon, so no minimum run time applicable
            id(minimum_run_time_passed) = true;
            id(switch_off_requested) = false;            
  - platform: gpio
    name: "WP Heat"
    pin: 19
    id: relay2
    interlock: *interlock_group
    interlock_wait_time: 20s
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      then:
        - lambda: |-
            //Update working mode
            id(working_mode) = 0;
            id(minimum_run_time_script).stop();
            id(anti_pendel_off).stop();
    on_turn_on:
      then:
        - lambda: |-
            //Update working mode
            id(working_mode) = 2;
            id(run_start) = true;
            id(minimum_run_time_passed) = false;
            id(switch_off_requested) = false;
            id(minimum_run_time_script).execute();
  - platform: output
    name: "Silent Mode"
    output: 'modbus_set_silent_mode'

# Eneco Toon anti pendel script. Toon sometimes temporarily switches the output off, while heat is still needed
# This script delays switching the heating of for x minutes. If heating switches back on within this timeframe the script stops
# An other 'nice' feature of Toon is that it sometimes switches on the heating for only 1 or 2 minutes and then off again
script:
  - id: anti_pendel_off
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("toon-delay", "anti_pendel_off called.");
          //If heating active and compressor is not running, switch off instantly
          if(!id(compressor_running).state && id(working_mode) == 2){
            ESP_LOGD("toon-delay", "Compressor not running. Instant off.");
            id(relay2).turn_off();
          }else {
            ESP_LOGD("toon-delay", "anti_pendel_off called. starting delay timer. minimum_run_time_passed: %d",id(minimum_run_time_passed));
          }
      - delay: !lambda "return id(toon_off_delay).state*60*1000;"
      - lambda: |-
          //If minimum run time passed switch off. Otherwise flag switch off requested (will be picked up by minimum_run_time_script)
          ESP_LOGD("toon-delay", "anti_pendel_off delay passed. minimum_run_time_passed: %d",id(minimum_run_time_passed));
          if(id(minimum_run_time_passed)||(!id(compressor_running).state && id(working_mode) == 2)){
            id(relay2).turn_off();
          } else {
            id(switch_off_requested) = true;
          }
  - id: anti_pendel_on
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("toon-delay", "anti_pendel_on called starting delay timer.");
      - delay: !lambda "return id(toon_on_delay).state*60*1000;"
      - lambda: |-
          ESP_LOGD("toon-delay", "anti_pendel_on delay passed starting HP.");
          //Turn on HP
          id(relay2).turn_on();
  - id: minimum_run_time_script
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("toon-delay", "minimum_run_time_script called starting delay timer.");
      - delay: !lambda "return id(minimum_run_time).state*60*1000;"
      - lambda: |-
          //Set minum run time passed to true, so that HP can switch off when Toon switches off (after delay)
          ESP_LOGD("toon-delay", "minimum_run_time_script delay passed. switch_off_requested: %d",id(switch_off_requested));
          id(minimum_run_time_passed) = true;
          //Check if switch off was already requested
          if(id(switch_off_requested)){
            //Switch off
            id(relay2).turn_off();
            id(anti_pendel_off).stop();
          }
          
modbus:
  id: modbus_lg
  uart_id: uart_modbus
  send_wait_time: 200ms
  
uart:
  tx_pin: GPIO26
  rx_pin: GPIO25
  baud_rate: 9600
  id: uart_modbus
  parity: none
  data_bits: 8
  stop_bits: 1

modbus_controller:
  - id: lg
    address: 0x1 # the Modbus device addr
    modbus_id: modbus_lg
    update_interval: 20s #this is our main 'clock' all dependel logic follows this pace
    setup_priority: -10

output:
  - platform: modbus_controller
    modbus_controller_id: lg
    id: water_temp_target_output
    register_type: holding
    address: 2
    value_type: U_WORD
    multiply: 1000
  - platform: modbus_controller
    modbus_controller_id: lg
    id: modbus_set_silent_mode
    register_type: coil
    address: 2
 
binary_sensor:
  - platform: gpio # Toon input signal is connected to this input pin
    pin:
      number: GPIO27
      mode:
        input: true
        pullup: false
    name: "WP Toon Signal"
    id: toon_signal
    filters:
      - delayed_on: 500ms # Debounce
    on_press:
      # Reset switch_off_requested
      - globals.set:
          id: switch_off_requested
          value: 'false'
      - script.execute: anti_pendel_on # Anti pendel script, to delay switch on for x minutes
      - script.stop: anti_pendel_off # Anti pendel script, to delay switch off for x minutes
    on_release:
      - script.execute: anti_pendel_off
      - script.stop: anti_pendel_on
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Pump Running"
    id: pump_running
    register_type: discrete_input
    skip_updates: 3
    address: 1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Compressor Running"
    id: compressor_running
    register_type: discrete_input
    skip_updates: 3
    address: 3
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Defrosting"
    id: defrosting
    register_type: discrete_input
    skip_updates: 6
    address: 4
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Silent Mode"
    id: silent_mode
    register_type: discrete_input
    skip_updates: 6
    address: 7

    
sensor:
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Bedrijfsmodus"
    id: bedrijfsmodus
    register_type: read
    address: 1
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water retour"
    id: water_temp_retour
    register_type: read
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water aanvoer"
    id: water_temp_aanvoer
    register_type: read
    address: 3
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
    on_value:
      then:
        - lambda: |-
            //Main program logic this loop runs every 'clock' cycle when modbus data is received for this sensor
            static int alive_timer = 0;
            
            //Set controller control mode to 'outlet' and set hysteresis to the setting you have on the controller (recommend 4)
            const static int hysteresis = 4;
            //Set to value that anti-pendel script will track (outlet/inlet) (recommend outlet)
            const float tracking_value = id(water_temp_retour).state;

            if(alive_timer == 0){
              //Post an 'alive' debug message in the logs every 300 seconds
              alive_timer = 16; //300 seconds
              ESP_LOGD("anti-pendel", "**alive** oat: %f inlet: %f outlet: %f ",id(buiten_temp).state,id(water_temp_retour).state,x);
            }
            alive_timer--;
            //Wait for valid oat reading
            if(isnan(id(buiten_temp).state)) return;
            //Do not run script if working mode = 0
            if(id(working_mode) == 0) return;
            
            //Hold previous script run ota value to check if it changed since last run
            static float prev_oat = 0;
            //Pump pre run time
            static int pre_run_time = 0;
            //System logic (to switch off agressive target setting after target is reached)
            static bool target_reached = false;
            
            //Calculate stooklijn target
            float oat = round(id(buiten_temp).state);
            //If no oat change, no update needed, unless forced or first run
            if(prev_oat != oat || id(force_update_stooklijn) || id(run_start)){
              prev_oat = oat;
              //reset force boolean
              id(force_update_stooklijn) = false;
              if(id(working_mode) == 1){
                //Cooling
                ESP_LOGD("stooklijn", "Stooklijn, working mode is cooling");
                id(stooklijn_target) = id(cooling_target_wtemp).state;
              } else {
                //Heating
                //Formula is wTemp = -Z x (OAT-20) + (20-hysteresis)
                //Formula to calculate -Z = ((wTempMax-(20-hysteresis)) / (OATMin - 20))
                const float Z = ((float)id(stooklijn_max_wtemp).state-(20-hysteresis))/(float)(((float)id(stooklijn_min_oat).state) - 20);
                ESP_LOGD("stooklijn", "Stooklijn, working mode is heating, with oat: %f, Z: %f",oat, Z);
                if(oat < id(stooklijn_min_oat).state) {
                  //If oat below minimum oat, clamp to minimum value
                  oat = id(stooklijn_min_oat).state;
                } else if (oat > 20) {
                  //If oat above max value, clamp to maximum value
                  oat = 20;
                }
                id(stooklijn_target) = (int)round((Z * (oat-20))+(20-hysteresis));
                //Add stooklijn offset
                id(stooklijn_target) = id(stooklijn_target) + id(wp_stooklijn_offset).state;
                //Make sure target is not above max water temp
                if(id(stooklijn_target) > id(stooklijn_max_wtemp).state) id(stooklijn_target) = id(stooklijn_max_wtemp).state;
                //Increase to minimum water temp when in heating mode (in case of radiators)
                if(id(stooklijn_target) < id(stooklijn_min_wtemp).state) id(stooklijn_target) = id(stooklijn_min_wtemp).state;
              }
              ESP_LOGD("stooklijn", "New stooklijn target value (after correction): %f", id(stooklijn_target));
              //Publish new stooklijn value to watertemp value sensor
              id(watertemp_target).publish_state(id(stooklijn_target));
            }
            //New anti-pendel target
            float temp_new_target = id(stooklijn_target);
            //Calculate new (anti pendel) target
            //Very basic algorithm
            //System initializes at the start of a run (when working mode changes to 1 or 2)
            //Then sets initial target to 'real' target, to allow HP to start up (if water temp below HP hysteresis setting)
            //When the compressor turns on the logic starts running, setting a new target at 2 degrees below actual return temp when actual within hysteresis degrees of target
            //When the new target equals the target temperature the logic stops, fixating the target so the HP can take over again an run its own logic
            //System resets at heating/cooling mode stop (system working mode 0) for example when the room thermostat stops the heating
            if(id(run_start)){
              //Initialize values. run_start is set to true by the switches that control heating/cooling mode
              pre_run_time = 5; // equals 100 seconds. Based on 20s 'clock'
              //Activate system
              target_reached = false;
              temp_new_target = id(stooklijn_target);
              ESP_LOGD("anti-pendel", "Run start initial values set; target: %f inlet: %f outlet: %f",id(stooklijn_target),x,id(water_temp_retour).state);
              id(run_start) = 0;
            }
            
            //System will only run when delta return vs target is < hysteresis to prevent stabilising on too low temperature
            const float delta = abs(id(stooklijn_target)-tracking_value);
            //Run when compressor is running and target not reached and actual return temp within hysteresis degrees of target
            if(id(compressor_running).state && !target_reached && delta < (hysteresis)){
              //Agressive target setting
              if(id(working_mode) == 1) temp_new_target = (((tracking_value+2)*10)/10;
              else if(id(working_mode) == 2) temp_new_target = (((tracking_value-2)*10)/10;
              //Make sure value is not below target (cooling), or above target (heating)
              if(id(working_mode) == 1 && temp_new_target < id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              else if(temp_new_target > id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              ESP_LOGD("anti-pendel", "RETURN_TEMP: %f OUTLET_TEMP: %f TARGET: %f PENDEL_TARGET: %f TRACKING_VALUE: %f",id(water_temp_retour).state,x,id(stooklijn_target),temp_new_target,tracking_value);
            } else if(id(compressor_running).state && !target_reached) {
              //Waiting for delta te become within range, less agressive target setting
              if(id(working_mode) == 1) {
                temp_new_target = round((tracking_value)*10)/10;
                if(temp_new_target < id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              } else if(id(working_mode) == 2){
                temp_new_target = round((tracking_value-1)*10)/10;
                if(temp_new_target > id(stooklijn_target)) temp_new_target = id(stooklijn_target);
              }
              ESP_LOGD("anti-pendel", "Waiting for delta RETURN_TEMP: %f OUTLET_TEMP: %f DELTA: %f PENDEL_TARGET: %f",id(water_temp_retour).state,x,delta,temp_new_target);
            } else if(!target_reached && pre_run_time > 0) {
              //Make sure target remains at stooklijn target to ensure compressor start
              temp_new_target = id(stooklijn_target);
              //Update pre_run_time counter
              ESP_LOGD("anti-pendel", "Waiting for pre_run_time: %i",pre_run_time);
              pre_run_time--;
            }
            
            //Make sure changes in stooklijn are processed when target reached
            if(target_reached){
                temp_new_target = id(stooklijn_target);
            }
            if(delta < 0.5 && id(compressor_running).state){
                //Deactive agressive target setting until next run
                temp_new_target = id(stooklijn_target);
                target_reached = true;
                ESP_LOGD("anti-pendel", "Target reached, maintaining target: %f pendel_target: %f",id(stooklijn_target),id(pendel_watertemp_target).state);
            }
            if(temp_new_target != id(var_pendel_watertemp_target) || id(var_pendel_watertemp_target) != id(doel_temp).state){
              //Set new target
              id(var_pendel_watertemp_target) = temp_new_target;
              //Update sensor
              id(pendel_watertemp_target).publish_state(id(var_pendel_watertemp_target));
              //Update target through modbus (set level needs value between 0-1, so divide by 100)
              id(water_temp_target_output).set_level(id(var_pendel_watertemp_target)*0.01);
              //ESP_LOGD("anti-pendel", "New pendel_watertemp_target set: %f outlet: %f",id(pendel_watertemp_target).state,x);
            }
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Garagetemperatuur"
    id: binnen_temp
    register_type: read
    address: 7
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Flow Rate"
    id: current_flow_rate
    register_type: read
    address: 8
    unit_of_measurement: "L/m"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Buitentemperatuur"
    id: buiten_temp
    register_type: read
    address: 12
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Compressor RPM"
    id: compressor_rpm
    register_type: read
    address: 24
    unit_of_measurement: "RPM"
    value_type: U_WORD
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Doeltemperatuur"
    id: doel_temp
    register_type: holding
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: template
    name: "Stooklijn Watertemp Target"
    id: watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return id(stooklijn_target);
  - platform: template
    name: "Anti-pendel Watertemp Target"
    id: pendel_watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return round(id(var_pendel_watertemp_target)*10)/10;
  - platform: wifi_signal
    name: "${device_name} WiFi Signal"
    update_interval: 120s
    accuracy_decimals: 0
  - platform: uptime
    name: "${device_name} Uptime"
    unit_of_measurement: days
    update_interval: 3600s
    accuracy_decimals: 1
    filters:
      - multiply: 0.000011574
# Sensors for ESP version and WIFI information
text_sensor:
  - platform: version
    name: "${device_name} ESPHome Version"
  - platform: wifi_info
    ip_address:
      name: "${device_name} ip"
    ssid:
      name: "${device_name} ssid"