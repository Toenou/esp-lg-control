esphome:
  name: esp-wp-control

packages:
  config_values: !include config/config.yaml

# Enable logging
logger:

globals:
  - id: stooklijn_target
    type: int
    restore_value: no
    initial_value: '30'
  - id: force_update_stooklijn
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: working_mode
    type: int
    restore_value: no
    initial_value: '0'
  - id: var_pendel_watertemp_target
    type: int
    restore_value: no
    initial_value: '30'
    
number:
  - platform: template
    name: "Stooklijn offset"
    id: wp_stooklijn_offset
    min_value: -5
    max_value: 5
    initial_value: 0
    step: 1
    restore_value: yes
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_min_oat
    name: "Stooklijn Minimum Buitentemperatuur"
    min_value: -25
    max_value: 10
    step: 1
    restore_value: yes
    initial_value: -15
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: stooklijn_max_wtemp
    name: "Stooklijn Maximum Watertemperatuur"
    min_value: 30
    max_value: 60
    step: 1
    restore_value: yes
    initial_value: 60
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;
  - platform: template
    id: cooling_target_wtemp
    name: "Koelmodus Watertemperatuur"
    min_value: 16
    max_value: 20
    step: 1
    restore_value: yes
    initial_value: 18
    unit_of_measurement: "°C"
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(force_update_stooklijn) = true;

switch:
  - platform: gpio
    name: "WP Cool"
    pin: 4
    id: relay1
    interlock: &interlock_group [relay1, relay2]
    interlock_wait_time: 2000ms
    restore_mode: ALWAYS_OFF
    on_turn_off:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 0;
            id(force_update_stooklijn) = true;
    on_turn_on:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 1;
            id(force_update_stooklijn) = true;
  - platform: gpio
    name: "WP Heat"
    pin: 5
    id: relay2
    interlock: *interlock_group
    interlock_wait_time: 2000ms
    restore_mode: ALWAYS_OFF
    on_turn_off:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 0;
            id(force_update_stooklijn) = true;
    on_turn_on:
      then:
        - lambda: |-
            // update working mode
            id(working_mode) = 2;
            id(force_update_stooklijn) = true;
            
# Eneco Toon anti pendel script. Toon sometimes temporarily switches the output off, while heat is still needed
# This script delays switching the heating of for 5 minutes. If heating switches back on within this timeframe the script stops
script:
  - id: anti_pendel
    mode: restart
    then:
      - delay: 300s
      - switch.turn_off: relay2

modbus:
  id: modbus_lg
  uart_id: uart_modbus
  send_wait_time: 200ms
  
uart:
  tx_pin: GPIO12
  rx_pin: GPIO14
  baud_rate: 9600
  id: uart_modbus
  parity: none
  data_bits: 8
  stop_bits: 1

modbus_controller:
  - id: lg
    address: 0x1 # the Modbus device addr
    modbus_id: modbus_lg
    update_interval: 15s
    setup_priority: -10

output:
  - platform: modbus_controller
    modbus_controller_id: lg
    id: water_temp_target_output
    register_type: holding
    address: 2
    value_type: U_WORD
    multiply: 1000

binary_sensor:
  - platform: gpio # Toon input signal is connected to this input pin
    pin:
      number: GPIO13
      mode:
        input: true
        pullup: false
    name: "WP Toon Signal"
    filters:
      - delayed_on: 500ms # Debounce
    on_press:
      - switch.turn_on: relay2
      - script.stop: anti_pendel # Anti pendel script, to delay switch off for 5 minutes
    on_release:
      - script.execute: anti_pendel
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Silent Mode"
    id: silent_mode
    register_type: discrete_input
    skip_updates: 3
    address: 7
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Pump Running"
    id: pump_running
    register_type: discrete_input
    skip_updates: 3
    address: 1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Compressor Running"
    id: compressor_running
    register_type: discrete_input
    skip_updates: 3
    address: 3
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Defrosting"
    id: defrosting
    register_type: discrete_input
    skip_updates: 3
    address: 4
    
sensor:
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water retour"
    id: water_temp_retour
    register_type: read
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Water aanvoer"
    id: water_temp_aanvoer
    register_type: read
    address: 3
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
    on_value:
      then:
        - lambda: |-
            //calculate new (anti pendel) target
            static float pendel_stooklijn_target = 30;
            if(id(working_mode) == 0) return;
            float temp_new_target = 30;
            //very basic algoritm, set target to current (rounded) outlet temp
            if(id(working_mode) == 1){
              // cooling
              temp_new_target = floor(x); //round down for cooling
              if(temp_new_target < id(stooklijn_target)) temp_new_target = id(stooklijn_target);
            } else {
              //heating
              temp_new_target = ceil(x); //round up for cooling
              if(temp_new_target > id(stooklijn_target)) temp_new_target = id(stooklijn_target);
            }
            if(temp_new_target != pendel_stooklijn_target){
              //set new target
              pendel_stooklijn_target = temp_new_target;
              //update sensor
              id(pendel_watertemp_target).publish_state(pendel_stooklijn_target);
              //update target through modbus (set level needs value between 0-1, so divide by 100)
              id(water_temp_target_output).set_level(pendel_stooklijn_target*0.01);
              ESP_LOGD("anti-pendel", "New pendel_stooklijn_target set outlet_temp: %f target: %f",x, pendel_stooklijn_target);
            }
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Garagetemperatuur"
    id: binnen_temp
    register_type: read
    address: 7
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Flow Rate"
    id: current_flow_rate
    register_type: read
    address: 8
    unit_of_measurement: "L/m"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Buitentemperatuur"
    id: buiten_temp
    register_type: read
    address: 12
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.1
    on_value:
      then:
        - lambda: |-
            // calculate stooklijn target
            static float prev_oat = 0;
            float oat = round(x);
            // if inactive (working mode 0) and not forced, no update needed
            if(id(working_mode) == 0 && !id(force_update_stooklijn)) return;
            // if oat same, or oat changed but mode is cooling (not OAT dependent) and no update forced then return
            if ((prev_oat == oat || id(working_mode) == 1) && !id(force_update_stooklijn)) return;
            prev_oat = oat;
            id(force_update_stooklijn) = false;
            if(id(working_mode) == 1){
              //Cooling
              ESP_LOGD("stooklijn", "Update forced, working mode is cooling");
              id(stooklijn_target) = id(cooling_target_wtemp).state;
            } else {
              //Heating
              //formula is wTemp = Z x Sqrt(-OAT+20) + 20
              //formula to calculate Z = wTempMax-20 / Sqrt(-OATMin + 20)
              const float Z = ((float)id(stooklijn_max_wtemp).state-20)/(float)sqrt((0 - (float)id(stooklijn_min_oat).state) + 20);
              ESP_LOGD("stooklijn", "Working mode is heating, with oat: %f, Z: %f",oat, Z);
              if(oat < id(stooklijn_min_oat).state) {
                oat = id(stooklijn_min_oat).state;
                ESP_LOGD("stooklijn", "Stooklijn oat < stooklijn_min_oat using stooklijn_min_oat for further calculation");
              } else if (oat > 20) {
                oat = 20;
                ESP_LOGD("stooklijn", "Stooklijn OAT > 20, using 20 for further calculation");
              }
              id(stooklijn_target) = (int)round((Z * sqrt((0-oat)+20))+20);
              if(id(stooklijn_target) > id(stooklijn_max_wtemp).state) id(stooklijn_target) = id(stooklijn_max_wtemp).state;
              if(id(stooklijn_target) < 20) id(stooklijn_target) = 20;
            }
            ESP_LOGD("stooklijn", "New stooklijn target value (after correction): %d", id(stooklijn_target));
            //publish new stooklijn value to watertemp value sensor
            id(watertemp_target).publish_state(id(stooklijn_target));
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Bedrijfsmodus"
    id: bedrijfsmodus
    register_type: read
    address: 1
    value_type: U_WORD
    on_value:
      then:
        - lambda: |-
            // set force update stooklijn if working mode is changed and log the change (for debugging)
            // In the scripts this data is not used, as it is unreliable due to modbus glitches
            if(id(working_mode) != (int)x) {
              id(force_update_stooklijn) = true;
              ESP_LOGD("modbus", "Modbus working_mode change from: %d to %d", id(working_mode), (int)x);
            }
  - platform: modbus_controller
    modbus_controller_id: lg
    name: "Doeltemperatuur"
    id: doel_temp
    register_type: holding
    address: 2
    unit_of_measurement: "°C"
    value_type: U_WORD
    accuracy_decimals: 1
    skip_updates: 6
    filters:
      - multiply: 0.1
  - platform: template
    name: "Stooklijn Watertemp Target"
    id: watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return id(stooklijn_target);
  - platform: template
    name: "Anti-pendel Watertemp Target"
    id: pendel_watertemp_target
    unit_of_measurement: "°C"
    update_interval: 3600s
    lambda: |-
        return id(var_pendel_watertemp_target);
